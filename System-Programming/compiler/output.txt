2	PREP	#include <stdio.h>
3	PREP	#include <stdlib.h>
4	REWD	int
4	IDEN	main
4	SPEC	(
4	REWD	int
4	IDEN	argc
4	OPER	,
4	REWD	char
4	OPER	*
4	IDEN	argv
4	OPER	[
4	OPER	]
4	SPEC	)
4	SPEC	{
5	REWD	char
5	IDEN	stringIn
5	OPER	[
5	INTE	100
5	OPER	]
5	OPER	=
5	SPEC	{
5	SPEC	}
5	SPEC	;
6	REWD	char
6	IDEN	stringArray
6	OPER	[
6	INTE	50
6	OPER	]
6	OPER	=
6	STR	
6	SPEC	;
7	REWD	int
7	IDEN	lineNo
7	OPER	=
7	INTE	1
7	SPEC	;
8	IDEN	FILE
8	OPER	*
8	IDEN	In
8	SPEC	;
9	IDEN	FILE
9	OPER	*
9	IDEN	Out
9	SPEC	;
10	IDEN	In
10	OPER	=
10	IDEN	fopen
10	SPEC	(
10	STR	sample.txt
10	OPER	,
10	STR	r
10	SPEC	)
10	SPEC	;
11	IDEN	Out
11	OPER	=
11	IDEN	fopen
11	SPEC	(
11	STR	output.txt
11	OPER	,
11	STR	w
11	SPEC	)
11	SPEC	;
12	REWD	if
12	SPEC	(
12	IDEN	In
12	OPER	==
12	IDEN	NULL
12	SPEC	)
12	SPEC	{
13	IDEN	printf
13	SPEC	(
13	STR	讀檔失敗!\n
13	SPEC	)
13	SPEC	;
14	REWD	return
14	INTE	0
14	SPEC	;
15	SPEC	}
16	REWD	while
16	SPEC	(
16	IDEN	fgets
16	SPEC	(
16	IDEN	stringIn
16	OPER	,
16	INTE	100
16	OPER	,
16	IDEN	In
16	SPEC	)
16	OPER	!=
16	IDEN	NULL
16	SPEC	)
16	SPEC	{
17	REWD	int
17	IDEN	x
17	OPER	=
17	INTE	0
17	SPEC	;
18	REWD	int
18	IDEN	y
18	OPER	=
18	INTE	0
18	SPEC	;
19	REWD	while
19	SPEC	(
19	IDEN	stringIn
19	OPER	[
19	IDEN	x
19	OPER	]
19	OPER	!=
19	CHAR	\n
19	SPEC	)
19	SPEC	{
20	REWD	switch
20	SPEC	(
20	IDEN	stringIn
20	OPER	[
20	IDEN	x
20	OPER	]
20	SPEC	)
20	SPEC	{
21	REWD	case
21	CHAR	/
21	SPEC	:
22	IDEN	x
22	OPER	++
22	SPEC	;
23	REWD	if
23	SPEC	(
23	IDEN	stringIn
23	OPER	[
23	IDEN	x
23	OPER	]
23	OPER	==
23	CHAR	/
23	SPEC	)
23	SPEC	{
24	IDEN	fprintf
24	SPEC	(
24	IDEN	Out
24	OPER	,
24	STR	%d 
24	OPER	,
24	IDEN	lineNo
24	SPEC	)
24	SPEC	;
25	IDEN	fprintf
25	SPEC	(
25	IDEN	Out
25	OPER	,
25	STR	SC 
25	SPEC	)
25	SPEC	;
26	IDEN	fgets
26	SPEC	(
26	IDEN	stringIn
26	OPER	,
26	INTE	100
26	OPER	,
26	IDEN	In
26	SPEC	)
26	SPEC	;
27	IDEN	lineNo
27	OPER	++
27	SPEC	;
28	IDEN	x
28	OPER	=
28	SPEC	;
29	IDEN	fprintf
29	SPEC	(
29	IDEN	Out
29	OPER	,
29	STR	//%s  \n
29	OPER	,
29	IDEN	stringArray
29	SPEC	)
29	SPEC	;
30	IDEN	fprintf
30	SPEC	(
30	IDEN	Out
30	OPER	,
30	STR	\n
30	SPEC	)
30	SPEC	;
31	SPEC	}
33	REWD	else
33	SPEC	{
34	IDEN	fprintf
34	SPEC	(
34	IDEN	Out
34	OPER	,
34	STR	%d 
34	OPER	,
34	IDEN	lineNo
34	SPEC	)
34	SPEC	;
35	IDEN	fprintf
35	SPEC	(
35	IDEN	Out
35	OPER	,
35	STR	OPER 
35	SPEC	)
35	SPEC	;
36	IDEN	fprintf
36	SPEC	(
36	IDEN	Out
36	OPER	,
36	STR	/ \n
36	SPEC	)
36	SPEC	;
37	IDEN	x
37	OPER	--
37	SPEC	;
38	SPEC	}
39	REWD	break
39	SPEC	;
40	REWD	case
40	CHAR	e
40	SPEC	:
41	IDEN	stringArray
41	OPER	[
41	IDEN	y
41	OPER	]
41	OPER	=
41	IDEN	stringIn
41	OPER	[
41	IDEN	x
41	OPER	]
41	SPEC	;
42	IDEN	x
42	OPER	++
42	SPEC	;
43	IDEN	y
43	OPER	++
43	SPEC	;
44	REWD	switch
44	SPEC	(
44	IDEN	stringIn
44	OPER	[
44	IDEN	x
44	OPER	]
44	SPEC	)
44	SPEC	{
45	REWD	case
45	CHAR	l
45	SPEC	:
46	IDEN	stringArray
46	OPER	[
46	IDEN	y
46	OPER	]
46	OPER	=
46	IDEN	stringIn
46	OPER	[
46	IDEN	x
46	OPER	]
46	SPEC	;
47	IDEN	x
47	OPER	++
47	SPEC	;
48	IDEN	y
48	OPER	++
48	SPEC	;
49	REWD	if
49	SPEC	(
49	SPEC	(
49	IDEN	stringIn
49	OPER	[
49	IDEN	x
49	OPER	]
49	OPER	==
49	CHAR	s
49	SPEC	)
49	OPER	&&
49	SPEC	(
49	IDEN	stringIn
49	OPER	[
49	IDEN	x
49	OPER	]
49	OPER	==
49	CHAR	e
49	SPEC	)
49	SPEC	)
49	SPEC	{
50	IDEN	x
50	OPER	++
50	SPEC	;
51	IDEN	fprintf
51	SPEC	(
51	IDEN	Out
51	OPER	,
51	STR	%d 
51	OPER	,
51	IDEN	lineNo
51	SPEC	)
51	SPEC	;
52	IDEN	fprintf
52	SPEC	(
52	IDEN	Out
52	OPER	,
52	STR	REWD 
52	SPEC	)
52	SPEC	;
53	IDEN	fprintf
53	SPEC	(
53	IDEN	Out
53	OPER	,
53	STR	else \n
53	SPEC	)
53	SPEC	;
54	SPEC	}
55	REWD	else
55	SPEC	{
56	REWD	while
56	SPEC	(
56	SPEC	(
56	IDEN	stringIn
56	OPER	[
56	IDEN	x
56	OPER	]
56	OPER	>=
56	CHAR	A
56	OPER	&&
56	IDEN	stringIn
56	OPER	[
56	IDEN	x
56	OPER	]
56	OPER	<=
56	CHAR	Z
56	SPEC	)
56	OPER	||
56	SPEC	(
56	IDEN	stringIn
56	OPER	[
56	IDEN	x
56	OPER	]
56	OPER	==
56	CHAR	_
56	SPEC	)
56	OPER	||
56	SPEC	(
56	IDEN	stringIn
56	OPER	[
56	IDEN	x
56	OPER	]
56	OPER	>=
56	CHAR	a
56	OPER	&&
56	IDEN	stringIn
56	OPER	[
56	IDEN	x
56	OPER	]
56	OPER	<=
56	CHAR	z
56	SPEC	)
56	SPEC	)
56	SPEC	{
57	IDEN	stringArray
57	OPER	[
57	IDEN	y
57	OPER	]
57	OPER	=
57	IDEN	stringIn
57	OPER	[
57	IDEN	x
57	OPER	]
57	SPEC	;
58	IDEN	y
58	OPER	++
58	SPEC	;
59	IDEN	x
59	OPER	++
59	SPEC	;
60	SPEC	}
61	IDEN	x
61	OPER	--
61	SPEC	;
62	IDEN	fprintf
62	SPEC	(
62	IDEN	Out
62	OPER	,
62	STR	%d 
62	OPER	,
62	IDEN	lineNo
62	SPEC	)
62	SPEC	;
63	IDEN	fprintf
63	SPEC	(
63	IDEN	Out
63	OPER	,
63	STR	IDEN 
63	SPEC	)
63	SPEC	;
64	IDEN	fprintf
64	SPEC	(
64	IDEN	Out
64	OPER	,
64	STR	%s  \n
64	OPER	,
64	IDEN	stringArray
64	SPEC	)
64	SPEC	;
65	SPEC	}
66	REWD	break
66	SPEC	;
67	REWD	default
67	SPEC	:
68	REWD	while
68	SPEC	(
68	SPEC	(
68	IDEN	stringIn
68	OPER	[
68	IDEN	x
68	OPER	]
68	OPER	>=
68	CHAR	A
68	OPER	&&
68	IDEN	stringIn
68	OPER	[
68	IDEN	x
68	OPER	]
68	OPER	<=
68	CHAR	Z
68	SPEC	)
68	OPER	||
68	SPEC	(
68	IDEN	stringIn
68	OPER	[
68	IDEN	x
68	OPER	]
68	OPER	==
68	CHAR	_
68	SPEC	)
68	OPER	||
68	SPEC	(
68	IDEN	stringIn
68	OPER	[
68	IDEN	x
68	OPER	]
68	OPER	>=
68	CHAR	a
68	OPER	&&
68	IDEN	stringIn
68	OPER	[
68	IDEN	x
68	OPER	]
68	OPER	<=
68	CHAR	z
68	SPEC	)
68	SPEC	)
68	SPEC	{
69	IDEN	stringArray
69	OPER	[
69	IDEN	y
69	OPER	]
69	OPER	=
69	IDEN	stringIn
69	OPER	[
69	IDEN	x
69	OPER	]
69	SPEC	;
70	IDEN	y
70	OPER	++
70	SPEC	;
71	IDEN	x
71	OPER	++
71	SPEC	;
72	SPEC	}
73	IDEN	x
73	OPER	--
73	SPEC	;
74	IDEN	fprintf
74	SPEC	(
74	IDEN	Out
74	OPER	,
74	STR	%d 
74	OPER	,
74	IDEN	lineNo
74	SPEC	)
74	SPEC	;
75	IDEN	fprintf
75	SPEC	(
75	IDEN	Out
75	OPER	,
75	STR	IDEN 
75	SPEC	)
75	SPEC	;
76	IDEN	fprintf
76	SPEC	(
76	IDEN	Out
76	OPER	,
76	STR	%s  \n
76	OPER	,
76	IDEN	stringArray
76	SPEC	)
76	SPEC	;
77	REWD	break
77	SPEC	;
78	SPEC	}
79	IDEN	y
79	OPER	=
79	INTE	0
79	SPEC	;
80	REWD	int
80	IDEN	loop2
80	OPER	=
80	INTE	0
80	SPEC	;
81	REWD	while
81	SPEC	(
81	IDEN	loop2
81	OPER	<
81	INTE	50
81	SPEC	)
81	SPEC	{
82	IDEN	stringArray
82	OPER	[
82	IDEN	loop2
82	OPER	]
82	OPER	=
82	CHAR	 
82	SPEC	;
83	IDEN	loop2
83	OPER	++
83	SPEC	;
84	SPEC	}
85	REWD	break
85	SPEC	;
86	REWD	case
86	CHAR	g
86	SPEC	:
87	IDEN	stringArray
87	OPER	[
87	IDEN	y
87	OPER	]
87	OPER	=
87	IDEN	stringIn
87	OPER	[
87	IDEN	x
87	OPER	]
87	SPEC	;
88	IDEN	x
88	OPER	++
88	SPEC	;
89	IDEN	y
89	OPER	++
89	SPEC	;
90	REWD	switch
90	SPEC	(
90	IDEN	stringIn
90	OPER	[
90	IDEN	x
90	OPER	]
90	SPEC	)
90	SPEC	{
91	REWD	case
91	CHAR	o
91	SPEC	:
92	IDEN	stringArray
92	OPER	[
92	IDEN	y
92	OPER	]
92	OPER	=
92	IDEN	stringIn
92	OPER	[
92	IDEN	x
92	OPER	]
92	SPEC	;
93	IDEN	x
93	OPER	++
93	SPEC	;
94	IDEN	y
94	OPER	++
94	SPEC	;
95	REWD	if
95	SPEC	(
95	SPEC	(
95	IDEN	stringIn
95	OPER	[
95	IDEN	x
95	OPER	]
95	OPER	==
95	CHAR	t
95	SPEC	)
95	OPER	&&
95	SPEC	(
95	IDEN	stringIn
95	OPER	[
95	IDEN	x
95	OPER	]
95	OPER	==
95	CHAR	o
95	SPEC	)
95	SPEC	)
95	SPEC	{
96	IDEN	x
96	OPER	++
96	SPEC	;
97	IDEN	fprintf
97	SPEC	(
97	IDEN	Out
97	OPER	,
97	STR	%d 
97	OPER	,
97	IDEN	lineNo
97	SPEC	)
97	SPEC	;
98	IDEN	fprintf
98	SPEC	(
98	IDEN	Out
98	OPER	,
98	STR	REWD 
98	SPEC	)
98	SPEC	;
99	IDEN	fprintf
99	SPEC	(
99	IDEN	Out
99	OPER	,
99	STR	goto \n
99	SPEC	)
99	SPEC	;
100	SPEC	}
101	REWD	else
101	SPEC	{
102	REWD	while
102	SPEC	(
102	SPEC	(
102	IDEN	stringIn
102	OPER	[
102	IDEN	x
102	OPER	]
102	OPER	>=
102	CHAR	A
102	OPER	&&
102	IDEN	stringIn
102	OPER	[
102	IDEN	x
102	OPER	]
102	OPER	<=
102	CHAR	Z
102	SPEC	)
102	OPER	||
102	SPEC	(
102	IDEN	stringIn
102	OPER	[
102	IDEN	x
102	OPER	]
102	OPER	==
102	CHAR	_
102	SPEC	)
102	OPER	||
102	SPEC	(
102	IDEN	stringIn
102	OPER	[
102	IDEN	x
102	OPER	]
102	OPER	>=
102	CHAR	a
102	OPER	&&
102	IDEN	stringIn
102	OPER	[
102	IDEN	x
102	OPER	]
102	OPER	<=
102	CHAR	z
102	SPEC	)
102	SPEC	)
102	SPEC	{
103	IDEN	stringArray
103	OPER	[
103	IDEN	y
103	OPER	]
103	OPER	=
103	IDEN	stringIn
103	OPER	[
103	IDEN	x
103	OPER	]
103	SPEC	;
104	IDEN	y
104	OPER	++
104	SPEC	;
105	IDEN	x
105	OPER	++
105	SPEC	;
106	SPEC	}
107	IDEN	x
107	OPER	--
107	SPEC	;
108	IDEN	fprintf
108	SPEC	(
108	IDEN	Out
108	OPER	,
108	STR	%d 
108	OPER	,
108	IDEN	lineNo
108	SPEC	)
108	SPEC	;
109	IDEN	fprintf
109	SPEC	(
109	IDEN	Out
109	OPER	,
109	STR	IDEN 
109	SPEC	)
109	SPEC	;
110	IDEN	fprintf
110	SPEC	(
110	IDEN	Out
110	OPER	,
110	STR	%s  \n
110	OPER	,
110	IDEN	stringArray
110	SPEC	)
110	SPEC	;
111	SPEC	}
112	REWD	break
112	SPEC	;
113	REWD	default
113	SPEC	:
114	REWD	while
114	SPEC	(
114	SPEC	(
114	IDEN	stringIn
114	OPER	[
114	IDEN	x
114	OPER	]
114	OPER	>=
114	CHAR	A
114	OPER	&&
114	IDEN	stringIn
114	OPER	[
114	IDEN	x
114	OPER	]
114	OPER	<=
114	CHAR	Z
114	SPEC	)
114	OPER	||
114	SPEC	(
114	IDEN	stringIn
114	OPER	[
114	IDEN	x
114	OPER	]
114	OPER	==
114	CHAR	_
114	SPEC	)
114	OPER	||
114	SPEC	(
114	IDEN	stringIn
114	OPER	[
114	IDEN	x
114	OPER	]
114	OPER	>=
114	CHAR	a
114	OPER	&&
114	IDEN	stringIn
114	OPER	[
114	IDEN	x
114	OPER	]
114	OPER	<=
114	CHAR	z
114	SPEC	)
114	SPEC	)
114	SPEC	{
115	IDEN	stringArray
115	OPER	[
115	IDEN	y
115	OPER	]
115	OPER	=
115	IDEN	stringIn
115	OPER	[
115	IDEN	x
115	OPER	]
115	SPEC	;
116	IDEN	y
116	OPER	++
116	SPEC	;
117	IDEN	x
117	OPER	++
117	SPEC	;
118	SPEC	}
119	IDEN	x
119	OPER	--
119	SPEC	;
120	IDEN	fprintf
120	SPEC	(
120	IDEN	Out
120	OPER	,
120	STR	%d 
120	OPER	,
120	IDEN	lineNo
120	SPEC	)
120	SPEC	;
121	IDEN	fprintf
121	SPEC	(
121	IDEN	Out
121	OPER	,
121	STR	IDEN 
121	SPEC	)
121	SPEC	;
122	IDEN	fprintf
122	SPEC	(
122	IDEN	Out
122	OPER	,
122	STR	%s  \n
122	OPER	,
122	IDEN	stringArray
122	SPEC	)
122	SPEC	;
123	REWD	break
123	SPEC	;
124	SPEC	}
125	IDEN	y
125	OPER	=
125	INTE	0
125	SPEC	;
126	REWD	int
126	IDEN	loop11
126	OPER	=
126	INTE	0
126	SPEC	;
127	REWD	while
127	SPEC	(
127	IDEN	loop11
127	OPER	<
127	INTE	50
127	SPEC	)
127	SPEC	{
128	IDEN	stringArray
128	OPER	[
128	IDEN	loop11
128	OPER	]
128	OPER	=
128	CHAR	 
128	SPEC	;
129	IDEN	loop11
129	OPER	++
129	SPEC	;
130	SPEC	}
131	REWD	break
131	SPEC	;
132	REWD	case
132	CHAR	u
132	SPEC	:
133	IDEN	stringArray
133	OPER	[
133	IDEN	y
133	OPER	]
133	OPER	=
133	IDEN	stringIn
133	OPER	[
133	IDEN	x
133	OPER	]
133	SPEC	;
134	IDEN	x
134	OPER	++
134	SPEC	;
135	IDEN	y
135	OPER	++
135	SPEC	;
136	REWD	switch
136	SPEC	(
136	IDEN	stringIn
136	OPER	[
136	IDEN	x
136	OPER	]
136	SPEC	)
136	SPEC	{
137	REWD	case
137	CHAR	n
137	SPEC	:
138	IDEN	stringArray
138	OPER	[
138	IDEN	y
138	OPER	]
138	OPER	=
138	IDEN	stringIn
138	OPER	[
138	IDEN	x
138	OPER	]
138	SPEC	;
139	IDEN	x
139	OPER	++
139	SPEC	;
140	IDEN	y
140	OPER	++
140	SPEC	;
141	REWD	if
141	SPEC	(
141	SPEC	(
141	IDEN	stringIn
141	OPER	[
141	IDEN	x
141	OPER	]
141	OPER	==
141	CHAR	s
141	SPEC	)
141	OPER	&&
141	SPEC	(
141	IDEN	stringIn
141	OPER	[
141	IDEN	x
141	OPER	]
141	OPER	==
141	CHAR	i
141	SPEC	)
141	OPER	&&
141	SPEC	(
141	IDEN	stringIn
141	OPER	[
141	IDEN	x
141	OPER	]
141	OPER	==
141	CHAR	g
141	SPEC	)
141	OPER	&&
141	SPEC	(
141	IDEN	stringIn
141	OPER	[
141	IDEN	x
141	OPER	]
141	OPER	==
141	CHAR	n
141	SPEC	)
141	OPER	&&
141	SPEC	(
141	IDEN	stringIn
141	OPER	[
141	IDEN	x
141	OPER	]
141	OPER	==
141	CHAR	e
141	SPEC	)
141	OPER	&&
141	SPEC	(
141	IDEN	stringIn
141	OPER	[
141	IDEN	x
141	OPER	]
141	OPER	==
141	CHAR	d
141	SPEC	)
141	SPEC	)
141	SPEC	{
142	IDEN	x
142	OPER	++
142	SPEC	;
143	IDEN	x
143	OPER	++
143	SPEC	;
144	IDEN	x
144	OPER	++
144	SPEC	;
145	IDEN	x
145	OPER	++
145	SPEC	;
146	IDEN	x
146	OPER	++
146	SPEC	;
147	IDEN	fprintf
147	SPEC	(
147	IDEN	Out
147	OPER	,
147	STR	%d 
147	OPER	,
147	IDEN	lineNo
147	SPEC	)
147	SPEC	;
148	IDEN	fprintf
148	SPEC	(
148	IDEN	Out
148	OPER	,
148	STR	REWD 
148	SPEC	)
148	SPEC	;
149	IDEN	fprintf
149	SPEC	(
149	IDEN	Out
149	OPER	,
149	STR	unsigned \n
149	SPEC	)
149	SPEC	;
150	SPEC	}
151	REWD	else
151	SPEC	{
152	REWD	while
152	SPEC	(
152	SPEC	(
152	IDEN	stringIn
152	OPER	[
152	IDEN	x
152	OPER	]
152	OPER	>=
152	CHAR	A
152	OPER	&&
152	IDEN	stringIn
152	OPER	[
152	IDEN	x
152	OPER	]
152	OPER	<=
152	CHAR	Z
152	SPEC	)
152	OPER	||
152	SPEC	(
152	IDEN	stringIn
152	OPER	[
152	IDEN	x
152	OPER	]
152	OPER	==
152	CHAR	_
152	SPEC	)
152	OPER	||
152	SPEC	(
152	IDEN	stringIn
152	OPER	[
152	IDEN	x
152	OPER	]
152	OPER	>=
152	CHAR	a
152	OPER	&&
152	IDEN	stringIn
152	OPER	[
152	IDEN	x
152	OPER	]
152	OPER	<=
152	CHAR	z
152	SPEC	)
152	SPEC	)
152	SPEC	{
153	IDEN	stringArray
153	OPER	[
153	IDEN	y
153	OPER	]
153	OPER	=
153	IDEN	stringIn
153	OPER	[
153	IDEN	x
153	OPER	]
153	SPEC	;
154	IDEN	y
154	OPER	++
154	SPEC	;
155	IDEN	x
155	OPER	++
155	SPEC	;
156	SPEC	}
157	IDEN	x
157	OPER	--
157	SPEC	;
158	IDEN	fprintf
158	SPEC	(
158	IDEN	Out
158	OPER	,
158	STR	%d 
158	OPER	,
158	IDEN	lineNo
158	SPEC	)
158	SPEC	;
159	IDEN	fprintf
159	SPEC	(
159	IDEN	Out
159	OPER	,
159	STR	IDEN 
159	SPEC	)
159	SPEC	;
160	IDEN	fprintf
160	SPEC	(
160	IDEN	Out
160	OPER	,
160	STR	%s  \n
160	OPER	,
160	IDEN	stringArray
160	SPEC	)
160	SPEC	;
161	SPEC	}
162	REWD	break
162	SPEC	;
163	REWD	default
163	SPEC	:
164	REWD	while
164	SPEC	(
164	SPEC	(
164	IDEN	stringIn
164	OPER	[
164	IDEN	x
164	OPER	]
164	OPER	>=
164	CHAR	A
164	OPER	&&
164	IDEN	stringIn
164	OPER	[
164	IDEN	x
164	OPER	]
164	OPER	<=
164	CHAR	Z
164	SPEC	)
164	OPER	||
164	SPEC	(
164	IDEN	stringIn
164	OPER	[
164	IDEN	x
164	OPER	]
164	OPER	==
164	CHAR	_
164	SPEC	)
164	OPER	||
164	SPEC	(
164	IDEN	stringIn
164	OPER	[
164	IDEN	x
164	OPER	]
164	OPER	>=
164	CHAR	a
164	OPER	&&
164	IDEN	stringIn
164	OPER	[
164	IDEN	x
164	OPER	]
164	OPER	<=
164	CHAR	z
164	SPEC	)
164	SPEC	)
164	SPEC	{
165	IDEN	stringArray
165	OPER	[
165	IDEN	y
165	OPER	]
165	OPER	=
165	IDEN	stringIn
165	OPER	[
165	IDEN	x
165	OPER	]
165	SPEC	;
166	IDEN	y
166	OPER	++
166	SPEC	;
167	IDEN	x
167	OPER	++
167	SPEC	;
168	SPEC	}
169	IDEN	x
169	OPER	--
169	SPEC	;
170	IDEN	fprintf
170	SPEC	(
170	IDEN	Out
170	OPER	,
170	STR	%d 
170	OPER	,
170	IDEN	lineNo
170	SPEC	)
170	SPEC	;
171	IDEN	fprintf
171	SPEC	(
171	IDEN	Out
171	OPER	,
171	STR	IDEN 
171	SPEC	)
171	SPEC	;
172	IDEN	fprintf
172	SPEC	(
172	IDEN	Out
172	OPER	,
172	STR	%s  \n
172	OPER	,
172	IDEN	stringArray
172	SPEC	)
172	SPEC	;
173	REWD	break
173	SPEC	;
174	SPEC	}
175	IDEN	y
175	OPER	=
175	INTE	0
175	SPEC	;
176	REWD	int
176	IDEN	loop12
176	OPER	=
176	INTE	0
176	SPEC	;
177	REWD	while
177	SPEC	(
177	IDEN	loop12
177	OPER	<
177	INTE	50
177	SPEC	)
177	SPEC	{
178	IDEN	stringArray
178	OPER	[
178	IDEN	loop12
178	OPER	]
178	OPER	=
178	CHAR	 
178	SPEC	;
179	IDEN	loop12
179	OPER	++
179	SPEC	;
180	SPEC	}
181	REWD	break
181	SPEC	;
182	REWD	case
182	CHAR	t
182	SPEC	:
183	IDEN	stringArray
183	OPER	[
183	IDEN	y
183	OPER	]
183	OPER	=
183	IDEN	stringIn
183	OPER	[
183	IDEN	x
183	OPER	]
183	SPEC	;
184	IDEN	x
184	OPER	++
184	SPEC	;
185	IDEN	y
185	OPER	++
185	SPEC	;
186	REWD	switch
186	SPEC	(
186	IDEN	stringIn
186	OPER	[
186	IDEN	x
186	OPER	]
186	SPEC	)
186	SPEC	{
187	REWD	case
187	CHAR	y
187	SPEC	:
188	IDEN	stringArray
188	OPER	[
188	IDEN	y
188	OPER	]
188	OPER	=
188	IDEN	stringIn
188	OPER	[
188	IDEN	x
188	OPER	]
188	SPEC	;
189	IDEN	x
189	OPER	++
189	SPEC	;
190	IDEN	y
190	OPER	++
190	SPEC	;
191	REWD	if
191	SPEC	(
191	SPEC	(
191	IDEN	stringIn
191	OPER	[
191	IDEN	x
191	OPER	]
191	OPER	==
191	CHAR	p
191	SPEC	)
191	OPER	&&
191	SPEC	(
191	IDEN	stringIn
191	OPER	[
191	IDEN	x
191	OPER	]
191	OPER	==
191	CHAR	e
191	SPEC	)
191	OPER	&&
191	SPEC	(
191	IDEN	stringIn
191	OPER	[
191	IDEN	x
191	OPER	]
191	OPER	==
191	CHAR	d
191	SPEC	)
191	OPER	&&
191	SPEC	(
191	IDEN	stringIn
191	OPER	[
191	IDEN	x
191	OPER	]
191	OPER	==
191	CHAR	e
191	SPEC	)
191	OPER	&&
191	SPEC	(
191	IDEN	stringIn
191	OPER	[
191	IDEN	x
191	OPER	]
191	OPER	==
191	CHAR	f
191	SPEC	)
191	SPEC	)
191	SPEC	{
192	IDEN	x
192	OPER	++
192	SPEC	;
193	IDEN	x
193	OPER	++
193	SPEC	;
194	IDEN	x
194	OPER	++
194	SPEC	;
195	IDEN	x
195	OPER	++
195	SPEC	;
196	IDEN	fprintf
196	SPEC	(
196	IDEN	Out
196	OPER	,
196	STR	%d 
196	OPER	,
196	IDEN	lineNo
196	SPEC	)
196	SPEC	;
197	IDEN	fprintf
197	SPEC	(
197	IDEN	Out
197	OPER	,
197	STR	REWD 
197	SPEC	)
197	SPEC	;
198	IDEN	fprintf
198	SPEC	(
198	IDEN	Out
198	OPER	,
198	STR	utypedef \n
198	SPEC	)
198	SPEC	;
199	SPEC	}
200	REWD	else
200	SPEC	{
201	REWD	while
201	SPEC	(
201	SPEC	(
201	IDEN	stringIn
201	OPER	[
201	IDEN	x
201	OPER	]
201	OPER	>=
201	CHAR	A
201	OPER	&&
201	IDEN	stringIn
201	OPER	[
201	IDEN	x
201	OPER	]
201	OPER	<=
201	CHAR	Z
201	SPEC	)
201	OPER	||
201	SPEC	(
201	IDEN	stringIn
201	OPER	[
201	IDEN	x
201	OPER	]
201	OPER	==
201	CHAR	_
201	SPEC	)
201	OPER	||
201	SPEC	(
201	IDEN	stringIn
201	OPER	[
201	IDEN	x
201	OPER	]
201	OPER	>=
201	CHAR	a
201	OPER	&&
201	IDEN	stringIn
201	OPER	[
201	IDEN	x
201	OPER	]
201	OPER	<=
201	CHAR	z
201	SPEC	)
201	SPEC	)
201	SPEC	{
202	IDEN	stringArray
202	OPER	[
202	IDEN	y
202	OPER	]
202	OPER	=
202	IDEN	stringIn
202	OPER	[
202	IDEN	x
202	OPER	]
202	SPEC	;
203	IDEN	y
203	OPER	++
203	SPEC	;
204	IDEN	x
204	OPER	++
204	SPEC	;
205	SPEC	}
206	IDEN	x
206	OPER	--
206	SPEC	;
207	IDEN	fprintf
207	SPEC	(
207	IDEN	Out
207	OPER	,
207	STR	%d 
207	OPER	,
207	IDEN	lineNo
207	SPEC	)
207	SPEC	;
208	IDEN	fprintf
208	SPEC	(
208	IDEN	Out
208	OPER	,
208	STR	IDEN 
208	SPEC	)
208	SPEC	;
209	IDEN	fprintf
209	SPEC	(
209	IDEN	Out
209	OPER	,
209	STR	%s  \n
209	OPER	,
209	IDEN	stringArray
209	SPEC	)
209	SPEC	;
210	SPEC	}
211	REWD	break
211	SPEC	;
212	REWD	default
212	SPEC	:
213	REWD	while
213	SPEC	(
213	SPEC	(
213	IDEN	stringIn
213	OPER	[
213	IDEN	x
213	OPER	]
213	OPER	>=
213	CHAR	A
213	OPER	&&
213	IDEN	stringIn
213	OPER	[
213	IDEN	x
213	OPER	]
213	OPER	<=
213	CHAR	Z
213	SPEC	)
213	OPER	||
213	SPEC	(
213	IDEN	stringIn
213	OPER	[
213	IDEN	x
213	OPER	]
213	OPER	==
213	CHAR	_
213	SPEC	)
213	OPER	||
213	SPEC	(
213	IDEN	stringIn
213	OPER	[
213	IDEN	x
213	OPER	]
213	OPER	>=
213	CHAR	a
213	OPER	&&
213	IDEN	stringIn
213	OPER	[
213	IDEN	x
213	OPER	]
213	OPER	<=
213	CHAR	z
213	SPEC	)
213	SPEC	)
213	SPEC	{
214	IDEN	stringArray
214	OPER	[
214	IDEN	y
214	OPER	]
214	OPER	=
214	IDEN	stringIn
214	OPER	[
214	IDEN	x
214	OPER	]
214	SPEC	;
215	IDEN	y
215	OPER	++
215	SPEC	;
216	IDEN	x
216	OPER	++
216	SPEC	;
217	SPEC	}
218	IDEN	x
218	OPER	--
218	SPEC	;
219	IDEN	fprintf
219	SPEC	(
219	IDEN	Out
219	OPER	,
219	STR	%d 
219	OPER	,
219	IDEN	lineNo
219	SPEC	)
219	SPEC	;
220	IDEN	fprintf
220	SPEC	(
220	IDEN	Out
220	OPER	,
220	STR	IDEN 
220	SPEC	)
220	SPEC	;
221	IDEN	fprintf
221	SPEC	(
221	IDEN	Out
221	OPER	,
221	STR	%s  \n
221	OPER	,
221	IDEN	stringArray
221	SPEC	)
221	SPEC	;
222	REWD	break
222	SPEC	;
223	SPEC	}
224	IDEN	y
224	OPER	=
224	INTE	0
224	SPEC	;
225	REWD	int
225	IDEN	loop13
225	OPER	=
225	INTE	0
225	SPEC	;
226	REWD	while
226	SPEC	(
226	IDEN	loop13
226	OPER	<
226	INTE	50
226	SPEC	)
226	SPEC	{
227	IDEN	stringArray
227	OPER	[
227	IDEN	loop13
227	OPER	]
227	OPER	=
227	CHAR	 
227	SPEC	;
228	IDEN	loop13
228	OPER	++
228	SPEC	;
229	SPEC	}
230	REWD	break
230	SPEC	;
231	REWD	case
231	CHAR	v
231	SPEC	:
232	IDEN	stringArray
232	OPER	[
232	IDEN	y
232	OPER	]
232	OPER	=
232	IDEN	stringIn
232	OPER	[
232	IDEN	x
232	OPER	]
232	SPEC	;
233	IDEN	x
233	OPER	++
233	SPEC	;
234	IDEN	y
234	OPER	++
234	SPEC	;
235	REWD	switch
235	SPEC	(
235	IDEN	stringIn
235	OPER	[
235	IDEN	x
235	OPER	]
235	SPEC	)
235	SPEC	{
236	REWD	case
236	CHAR	o
236	SPEC	:
237	IDEN	stringArray
237	OPER	[
237	IDEN	y
237	OPER	]
237	OPER	=
237	IDEN	stringIn
237	OPER	[
237	IDEN	x
237	OPER	]
237	SPEC	;
238	IDEN	x
238	OPER	++
238	SPEC	;
239	IDEN	y
239	OPER	++
239	SPEC	;
240	REWD	if
240	SPEC	(
240	SPEC	(
240	IDEN	stringIn
240	OPER	[
240	IDEN	x
240	OPER	]
240	OPER	==
240	CHAR	i
240	SPEC	)
240	OPER	&&
240	SPEC	(
240	IDEN	stringIn
240	OPER	[
240	IDEN	x
240	OPER	]
240	OPER	==
240	CHAR	d
240	SPEC	)
240	SPEC	)
240	SPEC	{
241	IDEN	x
241	OPER	++
241	SPEC	;
242	IDEN	fprintf
242	SPEC	(
242	IDEN	Out
242	OPER	,
242	STR	%d 
242	OPER	,
242	IDEN	lineNo
242	SPEC	)
242	SPEC	;
243	IDEN	fprintf
243	SPEC	(
243	IDEN	Out
243	OPER	,
243	STR	REWD 
243	SPEC	)
243	SPEC	;
244	IDEN	fprintf
244	SPEC	(
244	IDEN	Out
244	OPER	,
244	STR	void \n
244	SPEC	)
244	SPEC	;
245	SPEC	}
246	REWD	else
246	SPEC	{
247	REWD	while
247	SPEC	(
247	SPEC	(
247	IDEN	stringIn
247	OPER	[
247	IDEN	x
247	OPER	]
247	OPER	>=
247	CHAR	A
247	OPER	&&
247	IDEN	stringIn
247	OPER	[
247	IDEN	x
247	OPER	]
247	OPER	<=
247	CHAR	Z
247	SPEC	)
247	OPER	||
247	SPEC	(
247	IDEN	stringIn
247	OPER	[
247	IDEN	x
247	OPER	]
247	OPER	==
247	CHAR	_
247	SPEC	)
247	OPER	||
247	SPEC	(
247	IDEN	stringIn
247	OPER	[
247	IDEN	x
247	OPER	]
247	OPER	>=
247	CHAR	a
247	OPER	&&
247	IDEN	stringIn
247	OPER	[
247	IDEN	x
247	OPER	]
247	OPER	<=
247	CHAR	z
247	SPEC	)
247	SPEC	)
247	SPEC	{
248	IDEN	stringArray
248	OPER	[
248	IDEN	y
248	OPER	]
248	OPER	=
248	IDEN	stringIn
248	OPER	[
248	IDEN	x
248	OPER	]
248	SPEC	;
249	IDEN	y
249	OPER	++
249	SPEC	;
250	IDEN	x
250	OPER	++
250	SPEC	;
251	SPEC	}
252	IDEN	x
252	OPER	--
252	SPEC	;
253	IDEN	fprintf
253	SPEC	(
253	IDEN	Out
253	OPER	,
253	STR	%d 
253	OPER	,
253	IDEN	lineNo
253	SPEC	)
253	SPEC	;
254	IDEN	fprintf
254	SPEC	(
254	IDEN	Out
254	OPER	,
254	STR	IDEN 
254	SPEC	)
254	SPEC	;
255	IDEN	fprintf
255	SPEC	(
255	IDEN	Out
255	OPER	,
255	STR	%s  \n
255	OPER	,
255	IDEN	stringArray
255	SPEC	)
255	SPEC	;
256	SPEC	}
257	REWD	break
257	SPEC	;
258	REWD	default
258	SPEC	:
259	REWD	while
259	SPEC	(
259	SPEC	(
259	IDEN	stringIn
259	OPER	[
259	IDEN	x
259	OPER	]
259	OPER	>=
259	CHAR	A
259	OPER	&&
259	IDEN	stringIn
259	OPER	[
259	IDEN	x
259	OPER	]
259	OPER	<=
259	CHAR	Z
259	SPEC	)
259	OPER	||
259	SPEC	(
259	IDEN	stringIn
259	OPER	[
259	IDEN	x
259	OPER	]
259	OPER	==
259	CHAR	_
259	SPEC	)
259	OPER	||
259	SPEC	(
259	IDEN	stringIn
259	OPER	[
259	IDEN	x
259	OPER	]
259	OPER	>=
259	CHAR	a
259	OPER	&&
259	IDEN	stringIn
259	OPER	[
259	IDEN	x
259	OPER	]
259	OPER	<=
259	CHAR	z
259	SPEC	)
259	SPEC	)
259	SPEC	{
260	IDEN	stringArray
260	OPER	[
260	IDEN	y
260	OPER	]
260	OPER	=
260	IDEN	stringIn
260	OPER	[
260	IDEN	x
260	OPER	]
260	SPEC	;
261	IDEN	y
261	OPER	++
261	SPEC	;
262	IDEN	x
262	OPER	++
262	SPEC	;
263	SPEC	}
264	IDEN	x
264	OPER	--
264	SPEC	;
265	IDEN	fprintf
265	SPEC	(
265	IDEN	Out
265	OPER	,
265	STR	%d 
265	OPER	,
265	IDEN	lineNo
265	SPEC	)
265	SPEC	;
266	IDEN	fprintf
266	SPEC	(
266	IDEN	Out
266	OPER	,
266	STR	IDEN 
266	SPEC	)
266	SPEC	;
267	IDEN	fprintf
267	SPEC	(
267	IDEN	Out
267	OPER	,
267	STR	%s  \n
267	OPER	,
267	IDEN	stringArray
267	SPEC	)
267	SPEC	;
268	REWD	break
268	SPEC	;
269	SPEC	}
270	IDEN	y
270	OPER	=
270	INTE	0
270	SPEC	;
271	REWD	int
271	IDEN	loop14
271	OPER	=
271	INTE	0
271	SPEC	;
272	REWD	while
272	SPEC	(
272	IDEN	loop14
272	OPER	<
272	INTE	50
272	SPEC	)
272	SPEC	{
273	IDEN	stringArray
273	OPER	[
273	IDEN	loop14
273	OPER	]
273	OPER	=
273	CHAR	 
273	SPEC	;
274	IDEN	loop14
274	OPER	++
274	SPEC	;
275	SPEC	}
276	REWD	break
276	SPEC	;
277	REWD	case
277	CHAR	l
277	SPEC	:
278	IDEN	stringArray
278	OPER	[
278	IDEN	y
278	OPER	]
278	OPER	=
278	IDEN	stringIn
278	OPER	[
278	IDEN	x
278	OPER	]
278	SPEC	;
279	IDEN	x
279	OPER	++
279	SPEC	;
280	IDEN	y
280	OPER	++
280	SPEC	;
281	REWD	switch
281	SPEC	(
281	IDEN	stringIn
281	OPER	[
281	IDEN	x
281	OPER	]
281	SPEC	)
281	SPEC	{
282	REWD	case
282	CHAR	o
282	SPEC	:
283	IDEN	stringArray
283	OPER	[
283	IDEN	y
283	OPER	]
283	OPER	=
283	IDEN	stringIn
283	OPER	[
283	IDEN	x
283	OPER	]
283	SPEC	;
284	IDEN	x
284	OPER	++
284	SPEC	;
285	IDEN	y
285	OPER	++
285	SPEC	;
286	REWD	if
286	SPEC	(
286	IDEN	stringIn
286	OPER	[
286	IDEN	x
286	OPER	]
286	OPER	==
286	CHAR	n
286	OPER	&&
286	IDEN	stringIn
286	OPER	[
286	IDEN	x
286	OPER	]
286	OPER	==
286	CHAR	g
286	SPEC	)
286	SPEC	{
287	IDEN	x
287	OPER	++
287	SPEC	;
288	IDEN	fprintf
288	SPEC	(
288	IDEN	Out
288	OPER	,
288	STR	%d 
288	OPER	,
288	IDEN	lineNo
288	SPEC	)
288	SPEC	;
289	IDEN	fprintf
289	SPEC	(
289	IDEN	Out
289	OPER	,
289	STR	REWD 
289	SPEC	)
289	SPEC	;
290	IDEN	fprintf
290	SPEC	(
290	IDEN	Out
290	OPER	,
290	STR	long \n
290	SPEC	)
290	SPEC	;
291	SPEC	}
292	REWD	else
292	SPEC	{
293	REWD	while
293	SPEC	(
293	SPEC	(
293	IDEN	stringIn
293	OPER	[
293	IDEN	x
293	OPER	]
293	OPER	>=
293	CHAR	A
293	OPER	&&
293	IDEN	stringIn
293	OPER	[
293	IDEN	x
293	OPER	]
293	OPER	<=
293	CHAR	Z
293	SPEC	)
293	OPER	||
293	SPEC	(
293	IDEN	stringIn
293	OPER	[
293	IDEN	x
293	OPER	]
293	OPER	==
293	CHAR	_
293	SPEC	)
293	OPER	||
293	SPEC	(
293	IDEN	stringIn
293	OPER	[
293	IDEN	x
293	OPER	]
293	OPER	>=
293	CHAR	a
293	OPER	&&
293	IDEN	stringIn
293	OPER	[
293	IDEN	x
293	OPER	]
293	OPER	<=
293	CHAR	z
293	SPEC	)
293	SPEC	)
293	SPEC	{
294	IDEN	stringArray
294	OPER	[
294	IDEN	y
294	OPER	]
294	OPER	=
294	IDEN	stringIn
294	OPER	[
294	IDEN	x
294	OPER	]
294	SPEC	;
295	IDEN	y
295	OPER	++
295	SPEC	;
296	IDEN	x
296	OPER	++
296	SPEC	;
297	SPEC	}
298	IDEN	x
298	OPER	--
298	SPEC	;
299	IDEN	fprintf
299	SPEC	(
299	IDEN	Out
299	OPER	,
299	STR	%d 
299	OPER	,
299	IDEN	lineNo
299	SPEC	)
299	SPEC	;
300	IDEN	fprintf
300	SPEC	(
300	IDEN	Out
300	OPER	,
300	STR	IDEN 
300	SPEC	)
300	SPEC	;
301	IDEN	fprintf
301	SPEC	(
301	IDEN	Out
301	OPER	,
301	STR	%s  \n
301	OPER	,
301	IDEN	stringArray
301	SPEC	)
301	SPEC	;
302	SPEC	}
303	REWD	break
303	SPEC	;
304	REWD	default
304	SPEC	:
305	REWD	while
305	SPEC	(
305	SPEC	(
305	IDEN	stringIn
305	OPER	[
305	IDEN	x
305	OPER	]
305	OPER	>=
305	CHAR	A
305	OPER	&&
305	IDEN	stringIn
305	OPER	[
305	IDEN	x
305	OPER	]
305	OPER	<=
305	CHAR	Z
305	SPEC	)
305	OPER	||
305	SPEC	(
305	IDEN	stringIn
305	OPER	[
305	IDEN	x
305	OPER	]
305	OPER	==
305	CHAR	_
305	SPEC	)
305	OPER	||
305	SPEC	(
305	IDEN	stringIn
305	OPER	[
305	IDEN	x
305	OPER	]
305	OPER	>=
305	CHAR	a
305	OPER	&&
305	IDEN	stringIn
305	OPER	[
305	IDEN	x
305	OPER	]
305	OPER	<=
305	CHAR	z
305	SPEC	)
305	SPEC	)
305	SPEC	{
306	IDEN	stringArray
306	OPER	[
306	IDEN	y
306	OPER	]
306	OPER	=
306	IDEN	stringIn
306	OPER	[
306	IDEN	x
306	OPER	]
306	SPEC	;
307	IDEN	y
307	OPER	++
307	SPEC	;
308	IDEN	x
308	OPER	++
308	SPEC	;
309	SPEC	}
310	IDEN	x
310	OPER	--
310	SPEC	;
311	IDEN	fprintf
311	SPEC	(
311	IDEN	Out
311	OPER	,
311	STR	%d 
311	OPER	,
311	IDEN	lineNo
311	SPEC	)
311	SPEC	;
312	IDEN	fprintf
312	SPEC	(
312	IDEN	Out
312	OPER	,
312	STR	IDEN 
312	SPEC	)
312	SPEC	;
313	IDEN	fprintf
313	SPEC	(
313	IDEN	Out
313	OPER	,
313	STR	%s  \n
313	OPER	,
313	IDEN	stringArray
313	SPEC	)
313	SPEC	;
314	REWD	break
314	SPEC	;
315	SPEC	}
316	IDEN	y
316	OPER	=
316	INTE	0
316	SPEC	;
317	REWD	int
317	IDEN	loop10
317	OPER	=
317	INTE	0
317	SPEC	;
318	REWD	while
318	SPEC	(
318	IDEN	loop10
318	OPER	<
318	INTE	30
318	SPEC	)
318	SPEC	{
319	IDEN	stringArray
319	OPER	[
319	IDEN	loop10
319	OPER	]
319	OPER	=
319	CHAR	 
319	SPEC	;
320	IDEN	loop10
320	OPER	++
320	SPEC	;
321	SPEC	}
322	REWD	break
322	SPEC	;
323	REWD	case
323	CHAR	w
323	SPEC	:
324	IDEN	stringArray
324	OPER	[
324	IDEN	y
324	OPER	]
324	OPER	=
324	IDEN	stringIn
324	OPER	[
324	IDEN	x
324	OPER	]
324	SPEC	;
325	IDEN	x
325	OPER	++
325	SPEC	;
326	IDEN	y
326	OPER	++
326	SPEC	;
327	REWD	switch
327	SPEC	(
327	IDEN	stringIn
327	OPER	[
327	IDEN	x
327	OPER	]
327	SPEC	)
327	SPEC	{
328	REWD	case
328	CHAR	h
328	SPEC	:
329	IDEN	stringArray
329	OPER	[
329	IDEN	y
329	OPER	]
329	OPER	=
329	IDEN	stringIn
329	OPER	[
329	IDEN	x
329	OPER	]
329	SPEC	;
330	IDEN	x
330	OPER	++
330	SPEC	;
331	IDEN	y
331	OPER	++
331	SPEC	;
332	REWD	if
332	SPEC	(
332	SPEC	(
332	IDEN	stringIn
332	OPER	[
332	IDEN	x
332	OPER	]
332	OPER	==
332	CHAR	i
332	SPEC	)
332	OPER	&&
332	SPEC	(
332	IDEN	stringIn
332	OPER	[
332	IDEN	x
332	OPER	]
332	OPER	==
332	CHAR	l
332	SPEC	)
332	OPER	&&
332	SPEC	(
332	IDEN	stringIn
332	OPER	[
332	IDEN	x
332	OPER	]
332	OPER	==
332	CHAR	e
332	SPEC	)
332	SPEC	)
332	SPEC	{
333	IDEN	x
333	OPER	++
333	SPEC	;
334	IDEN	x
334	OPER	++
334	SPEC	;
335	IDEN	fprintf
335	SPEC	(
335	IDEN	Out
335	OPER	,
335	STR	%d 
335	OPER	,
335	IDEN	lineNo
335	SPEC	)
335	SPEC	;
336	IDEN	fprintf
336	SPEC	(
336	IDEN	Out
336	OPER	,
336	STR	REWD 
336	SPEC	)
336	SPEC	;
337	IDEN	fprintf
337	SPEC	(
337	IDEN	Out
337	OPER	,
337	STR	while \n
337	SPEC	)
337	SPEC	;
338	SPEC	}
339	REWD	else
339	SPEC	{
340	REWD	while
340	SPEC	(
340	SPEC	(
340	IDEN	stringIn
340	OPER	[
340	IDEN	x
340	OPER	]
340	OPER	>=
340	CHAR	A
340	OPER	&&
340	IDEN	stringIn
340	OPER	[
340	IDEN	x
340	OPER	]
340	OPER	<=
340	CHAR	Z
340	SPEC	)
340	OPER	||
340	SPEC	(
340	IDEN	stringIn
340	OPER	[
340	IDEN	x
340	OPER	]
340	OPER	==
340	CHAR	_
340	SPEC	)
340	OPER	||
340	SPEC	(
340	IDEN	stringIn
340	OPER	[
340	IDEN	x
340	OPER	]
340	OPER	>=
340	CHAR	a
340	OPER	&&
340	IDEN	stringIn
340	OPER	[
340	IDEN	x
340	OPER	]
340	OPER	<=
340	CHAR	z
340	SPEC	)
340	SPEC	)
340	SPEC	{
341	IDEN	stringArray
341	OPER	[
341	IDEN	y
341	OPER	]
341	OPER	=
341	IDEN	stringIn
341	OPER	[
341	IDEN	x
341	OPER	]
341	SPEC	;
342	IDEN	y
342	OPER	++
342	SPEC	;
343	IDEN	x
343	OPER	++
343	SPEC	;
344	SPEC	}
345	IDEN	x
345	OPER	--
345	SPEC	;
346	IDEN	fprintf
346	SPEC	(
346	IDEN	Out
346	OPER	,
346	STR	%d 
346	OPER	,
346	IDEN	lineNo
346	SPEC	)
346	SPEC	;
347	IDEN	fprintf
347	SPEC	(
347	IDEN	Out
347	OPER	,
347	STR	IDEN 
347	SPEC	)
347	SPEC	;
348	IDEN	fprintf
348	SPEC	(
348	IDEN	Out
348	OPER	,
348	STR	%s  \n
348	OPER	,
348	IDEN	stringArray
348	SPEC	)
348	SPEC	;
349	SPEC	}
350	REWD	break
350	SPEC	;
351	REWD	default
351	SPEC	:
352	REWD	while
352	SPEC	(
352	SPEC	(
352	IDEN	stringIn
352	OPER	[
352	IDEN	x
352	OPER	]
352	OPER	>=
352	CHAR	A
352	OPER	&&
352	IDEN	stringIn
352	OPER	[
352	IDEN	x
352	OPER	]
352	OPER	<=
352	CHAR	Z
352	SPEC	)
352	OPER	||
352	SPEC	(
352	IDEN	stringIn
352	OPER	[
352	IDEN	x
352	OPER	]
352	OPER	==
352	CHAR	_
352	SPEC	)
352	OPER	||
352	SPEC	(
352	IDEN	stringIn
352	OPER	[
352	IDEN	x
352	OPER	]
352	OPER	>=
352	CHAR	a
352	OPER	&&
352	IDEN	stringIn
352	OPER	[
352	IDEN	x
352	OPER	]
352	OPER	<=
352	CHAR	z
352	SPEC	)
352	SPEC	)
352	SPEC	{
353	IDEN	stringArray
353	OPER	[
353	IDEN	y
353	OPER	]
353	OPER	=
353	IDEN	stringIn
353	OPER	[
353	IDEN	x
353	OPER	]
353	SPEC	;
354	IDEN	y
354	OPER	++
354	SPEC	;
355	IDEN	x
355	OPER	++
355	SPEC	;
356	SPEC	}
357	IDEN	x
357	OPER	--
357	SPEC	;
358	IDEN	fprintf
358	SPEC	(
358	IDEN	Out
358	OPER	,
358	STR	%d 
358	OPER	,
358	IDEN	lineNo
358	SPEC	)
358	SPEC	;
359	IDEN	fprintf
359	SPEC	(
359	IDEN	Out
359	OPER	,
359	STR	IDEN 
359	SPEC	)
359	SPEC	;
360	IDEN	fprintf
360	SPEC	(
360	IDEN	Out
360	OPER	,
360	STR	%s  \n
360	OPER	,
360	IDEN	stringArray
360	SPEC	)
360	SPEC	;
361	REWD	break
361	SPEC	;
362	SPEC	}
363	IDEN	y
363	OPER	=
363	INTE	0
363	SPEC	;
364	REWD	int
364	IDEN	loop3
364	OPER	=
364	INTE	0
364	SPEC	;
365	REWD	while
365	SPEC	(
365	IDEN	loop3
365	OPER	<
365	INTE	50
365	SPEC	)
365	SPEC	{
366	IDEN	stringArray
366	OPER	[
366	IDEN	loop3
366	OPER	]
366	OPER	=
366	CHAR	 
366	SPEC	;
367	IDEN	loop3
367	OPER	++
367	SPEC	;
368	SPEC	}
369	REWD	break
369	SPEC	;
370	REWD	case
370	CHAR	i
370	SPEC	:
371	IDEN	stringArray
371	OPER	[
371	IDEN	y
371	OPER	]
371	OPER	=
371	IDEN	stringIn
371	OPER	[
371	IDEN	x
371	OPER	]
371	SPEC	;
372	IDEN	x
372	OPER	++
372	SPEC	;
373	IDEN	y
373	OPER	++
373	SPEC	;
374	REWD	switch
374	SPEC	(
374	IDEN	stringIn
374	OPER	[
374	IDEN	x
374	OPER	]
374	SPEC	)
374	SPEC	{
375	REWD	case
375	CHAR	f
375	SPEC	:
376	IDEN	fprintf
376	SPEC	(
376	IDEN	Out
376	OPER	,
376	STR	%d 
376	OPER	,
376	IDEN	lineNo
376	SPEC	)
376	SPEC	;
377	IDEN	fprintf
377	SPEC	(
377	IDEN	Out
377	OPER	,
377	STR	REWD 
377	SPEC	)
377	SPEC	;
378	IDEN	fprintf
378	SPEC	(
378	IDEN	Out
378	OPER	,
378	STR	if \n
378	SPEC	)
378	SPEC	;
379	REWD	break
379	SPEC	;
380	REWD	case
380	CHAR	n
380	SPEC	:
381	IDEN	stringArray
381	OPER	[
381	IDEN	y
381	OPER	]
381	OPER	=
381	IDEN	stringIn
381	OPER	[
381	IDEN	x
381	OPER	]
381	SPEC	;
382	IDEN	x
382	OPER	++
382	SPEC	;
383	IDEN	y
383	OPER	++
383	SPEC	;
384	REWD	if
384	SPEC	(
384	IDEN	stringIn
384	OPER	[
384	IDEN	x
384	OPER	]
384	OPER	==
384	CHAR	t
384	SPEC	)
384	SPEC	{
385	IDEN	fprintf
385	SPEC	(
385	IDEN	Out
385	OPER	,
385	STR	%d 
385	OPER	,
385	IDEN	lineNo
385	SPEC	)
385	SPEC	;
386	IDEN	fprintf
386	SPEC	(
386	IDEN	Out
386	OPER	,
386	STR	REWD 
386	SPEC	)
386	SPEC	;
387	IDEN	fprintf
387	SPEC	(
387	IDEN	Out
387	OPER	,
387	STR	int \n
387	SPEC	)
387	SPEC	;
388	SPEC	}
389	REWD	else
389	SPEC	{
390	REWD	while
390	SPEC	(
390	SPEC	(
390	IDEN	stringIn
390	OPER	[
390	IDEN	x
390	OPER	]
390	OPER	>=
390	CHAR	A
390	OPER	&&
390	IDEN	stringIn
390	OPER	[
390	IDEN	x
390	OPER	]
390	OPER	<=
390	CHAR	Z
390	SPEC	)
390	OPER	||
390	SPEC	(
390	IDEN	stringIn
390	OPER	[
390	IDEN	x
390	OPER	]
390	OPER	==
390	CHAR	_
390	SPEC	)
390	OPER	||
390	SPEC	(
390	IDEN	stringIn
390	OPER	[
390	IDEN	x
390	OPER	]
390	OPER	>=
390	CHAR	a
390	OPER	&&
390	IDEN	stringIn
390	OPER	[
390	IDEN	x
390	OPER	]
390	OPER	<=
390	CHAR	z
390	SPEC	)
390	SPEC	)
390	SPEC	{
391	IDEN	stringArray
391	OPER	[
391	IDEN	y
391	OPER	]
391	OPER	=
391	IDEN	stringIn
391	OPER	[
391	IDEN	x
391	OPER	]
391	SPEC	;
392	IDEN	y
392	OPER	++
392	SPEC	;
393	IDEN	x
393	OPER	++
393	SPEC	;
394	SPEC	}
395	IDEN	x
395	OPER	--
395	SPEC	;
396	IDEN	fprintf
396	SPEC	(
396	IDEN	Out
396	OPER	,
396	STR	%d 
396	OPER	,
396	IDEN	lineNo
396	SPEC	)
396	SPEC	;
397	IDEN	fprintf
397	SPEC	(
397	IDEN	Out
397	OPER	,
397	STR	IDEN 
397	SPEC	)
397	SPEC	;
398	IDEN	fprintf
398	SPEC	(
398	IDEN	Out
398	OPER	,
398	STR	%s  \n
398	OPER	,
398	IDEN	stringArray
398	SPEC	)
398	SPEC	;
399	SPEC	}
400	REWD	break
400	SPEC	;
401	REWD	default
401	SPEC	:
402	REWD	while
402	SPEC	(
402	SPEC	(
402	IDEN	stringIn
402	OPER	[
402	IDEN	x
402	OPER	]
402	OPER	>=
402	CHAR	A
402	OPER	&&
402	IDEN	stringIn
402	OPER	[
402	IDEN	x
402	OPER	]
402	OPER	<=
402	CHAR	Z
402	SPEC	)
402	OPER	||
402	SPEC	(
402	IDEN	stringIn
402	OPER	[
402	IDEN	x
402	OPER	]
402	OPER	==
402	CHAR	_
402	SPEC	)
402	OPER	||
402	SPEC	(
402	IDEN	stringIn
402	OPER	[
402	IDEN	x
402	OPER	]
402	OPER	>=
402	CHAR	a
402	OPER	&&
402	IDEN	stringIn
402	OPER	[
402	IDEN	x
402	OPER	]
402	OPER	<=
402	CHAR	z
402	SPEC	)
402	SPEC	)
402	SPEC	{
403	IDEN	stringArray
403	OPER	[
403	IDEN	y
403	OPER	]
403	OPER	=
403	IDEN	stringIn
403	OPER	[
403	IDEN	x
403	OPER	]
403	SPEC	;
404	IDEN	y
404	OPER	++
404	SPEC	;
405	IDEN	x
405	OPER	++
405	SPEC	;
406	SPEC	}
407	IDEN	x
407	OPER	--
407	SPEC	;
408	IDEN	fprintf
408	SPEC	(
408	IDEN	Out
408	OPER	,
408	STR	%d 
408	OPER	,
408	IDEN	lineNo
408	SPEC	)
408	SPEC	;
409	IDEN	fprintf
409	SPEC	(
409	IDEN	Out
409	OPER	,
409	STR	IDEN 
409	SPEC	)
409	SPEC	;
410	IDEN	fprintf
410	SPEC	(
410	IDEN	Out
410	OPER	,
410	STR	%s  \n
410	OPER	,
410	IDEN	stringArray
410	SPEC	)
410	SPEC	;
411	REWD	break
411	SPEC	;
412	SPEC	}
413	IDEN	y
413	OPER	=
413	INTE	0
413	SPEC	;
414	REWD	int
414	IDEN	loop1
414	OPER	=
414	INTE	0
414	SPEC	;
415	REWD	while
415	SPEC	(
415	IDEN	loop1
415	OPER	<
415	INTE	50
415	SPEC	)
415	SPEC	{
416	IDEN	stringArray
416	OPER	[
416	IDEN	loop1
416	OPER	]
416	OPER	=
416	CHAR	 
416	SPEC	;
417	IDEN	loop1
417	OPER	++
417	SPEC	;
418	SPEC	}
419	REWD	break
419	SPEC	;
420	REWD	case
420	CHAR	f
420	SPEC	:
421	IDEN	stringArray
421	OPER	[
421	IDEN	y
421	OPER	]
421	OPER	=
421	IDEN	stringIn
421	OPER	[
421	IDEN	x
421	OPER	]
421	SPEC	;
422	IDEN	x
422	OPER	++
422	SPEC	;
423	IDEN	y
423	OPER	++
423	SPEC	;
424	REWD	switch
424	SPEC	(
424	IDEN	stringIn
424	OPER	[
424	IDEN	x
424	OPER	]
424	SPEC	)
424	SPEC	{
425	REWD	case
425	CHAR	o
425	SPEC	:
426	IDEN	stringArray
426	OPER	[
426	IDEN	y
426	OPER	]
426	OPER	=
426	IDEN	stringIn
426	OPER	[
426	IDEN	x
426	OPER	]
426	SPEC	;
427	IDEN	x
427	OPER	++
427	SPEC	;
428	IDEN	y
428	OPER	++
428	SPEC	;
429	REWD	if
429	SPEC	(
429	IDEN	stringIn
429	OPER	[
429	IDEN	x
429	OPER	]
429	OPER	==
429	CHAR	r
429	SPEC	)
429	SPEC	{
430	IDEN	fprintf
430	SPEC	(
430	IDEN	Out
430	OPER	,
430	STR	%d 
430	OPER	,
430	IDEN	lineNo
430	SPEC	)
430	SPEC	;
431	IDEN	fprintf
431	SPEC	(
431	IDEN	Out
431	OPER	,
431	STR	REWD 
431	SPEC	)
431	SPEC	;
432	IDEN	fprintf
432	SPEC	(
432	IDEN	Out
432	OPER	,
432	STR	for \n
432	SPEC	)
432	SPEC	;
433	SPEC	}
434	REWD	else
434	SPEC	{
435	REWD	while
435	SPEC	(
435	SPEC	(
435	IDEN	stringIn
435	OPER	[
435	IDEN	x
435	OPER	]
435	OPER	>=
435	CHAR	A
435	OPER	&&
435	IDEN	stringIn
435	OPER	[
435	IDEN	x
435	OPER	]
435	OPER	<=
435	CHAR	Z
435	SPEC	)
435	OPER	||
435	SPEC	(
435	IDEN	stringIn
435	OPER	[
435	IDEN	x
435	OPER	]
435	OPER	==
435	CHAR	_
435	SPEC	)
435	OPER	||
435	SPEC	(
435	IDEN	stringIn
435	OPER	[
435	IDEN	x
435	OPER	]
435	OPER	>=
435	CHAR	a
435	OPER	&&
435	IDEN	stringIn
435	OPER	[
435	IDEN	x
435	OPER	]
435	OPER	<=
435	CHAR	z
435	SPEC	)
435	SPEC	)
435	SPEC	{
436	IDEN	stringArray
436	OPER	[
436	IDEN	y
436	OPER	]
436	OPER	=
436	IDEN	stringIn
436	OPER	[
436	IDEN	x
436	OPER	]
436	SPEC	;
437	IDEN	y
437	OPER	++
437	SPEC	;
438	IDEN	x
438	OPER	++
438	SPEC	;
439	SPEC	}
440	IDEN	x
440	OPER	--
440	SPEC	;
441	IDEN	fprintf
441	SPEC	(
441	IDEN	Out
441	OPER	,
441	STR	%d 
441	OPER	,
441	IDEN	lineNo
441	SPEC	)
441	SPEC	;
442	IDEN	fprintf
442	SPEC	(
442	IDEN	Out
442	OPER	,
442	STR	IDEN 
442	SPEC	)
442	SPEC	;
443	IDEN	fprintf
443	SPEC	(
443	IDEN	Out
443	OPER	,
443	STR	%s  \n
443	OPER	,
443	IDEN	stringArray
443	SPEC	)
443	SPEC	;
444	SPEC	}
445	REWD	break
445	SPEC	;
446	REWD	case
446	CHAR	l
446	SPEC	:
447	IDEN	stringArray
447	OPER	[
447	IDEN	y
447	OPER	]
447	OPER	=
447	IDEN	stringIn
447	OPER	[
447	IDEN	x
447	OPER	]
447	SPEC	;
448	IDEN	x
448	OPER	++
448	SPEC	;
449	IDEN	y
449	OPER	++
449	SPEC	;
450	REWD	if
450	SPEC	(
450	SPEC	(
450	IDEN	stringIn
450	OPER	[
450	IDEN	x
450	OPER	]
450	OPER	==
450	CHAR	o
450	SPEC	)
450	OPER	&&
450	SPEC	(
450	IDEN	stringIn
450	OPER	[
450	IDEN	x
450	OPER	]
450	OPER	==
450	CHAR	a
450	SPEC	)
450	OPER	&&
450	SPEC	(
450	IDEN	stringIn
450	OPER	[
450	IDEN	x
450	OPER	]
450	OPER	==
450	CHAR	t
450	SPEC	)
450	SPEC	)
450	SPEC	{
451	IDEN	x
451	OPER	++
451	SPEC	;
452	IDEN	x
452	OPER	++
452	SPEC	;
453	IDEN	fprintf
453	SPEC	(
453	IDEN	Out
453	OPER	,
453	STR	%d 
453	OPER	,
453	IDEN	lineNo
453	SPEC	)
453	SPEC	;
454	IDEN	fprintf
454	SPEC	(
454	IDEN	Out
454	OPER	,
454	STR	REWD 
454	SPEC	)
454	SPEC	;
455	IDEN	fprintf
455	SPEC	(
455	IDEN	Out
455	OPER	,
455	STR	float \n
455	SPEC	)
455	SPEC	;
456	SPEC	}
457	REWD	else
457	SPEC	{
458	REWD	while
458	SPEC	(
458	SPEC	(
458	IDEN	stringIn
458	OPER	[
458	IDEN	x
458	OPER	]
458	OPER	>=
458	CHAR	A
458	OPER	&&
458	IDEN	stringIn
458	OPER	[
458	IDEN	x
458	OPER	]
458	OPER	<=
458	CHAR	Z
458	SPEC	)
458	OPER	||
458	SPEC	(
458	IDEN	stringIn
458	OPER	[
458	IDEN	x
458	OPER	]
458	OPER	==
458	CHAR	_
458	SPEC	)
458	OPER	||
458	SPEC	(
458	IDEN	stringIn
458	OPER	[
458	IDEN	x
458	OPER	]
458	OPER	>=
458	CHAR	a
458	OPER	&&
458	IDEN	stringIn
458	OPER	[
458	IDEN	x
458	OPER	]
458	OPER	<=
458	CHAR	z
458	SPEC	)
458	SPEC	)
458	SPEC	{
459	IDEN	stringArray
459	OPER	[
459	IDEN	y
459	OPER	]
459	OPER	=
459	IDEN	stringIn
459	OPER	[
459	IDEN	x
459	OPER	]
459	SPEC	;
460	IDEN	y
460	OPER	++
460	SPEC	;
461	IDEN	x
461	OPER	++
461	SPEC	;
462	SPEC	}
463	IDEN	x
463	OPER	--
463	SPEC	;
464	IDEN	fprintf
464	SPEC	(
464	IDEN	Out
464	OPER	,
464	STR	%d 
464	OPER	,
464	IDEN	lineNo
464	SPEC	)
464	SPEC	;
465	IDEN	fprintf
465	SPEC	(
465	IDEN	Out
465	OPER	,
465	STR	IDEN 
465	SPEC	)
465	SPEC	;
466	IDEN	fprintf
466	SPEC	(
466	IDEN	Out
466	OPER	,
466	STR	%s  \n
466	OPER	,
466	IDEN	stringArray
466	SPEC	)
466	SPEC	;
467	SPEC	}
468	REWD	break
468	SPEC	;
469	REWD	default
469	SPEC	:
470	REWD	while
470	SPEC	(
470	SPEC	(
470	IDEN	stringIn
470	OPER	[
470	IDEN	x
470	OPER	]
470	OPER	>=
470	CHAR	A
470	OPER	&&
470	IDEN	stringIn
470	OPER	[
470	IDEN	x
470	OPER	]
470	OPER	<=
470	CHAR	Z
470	SPEC	)
470	OPER	||
470	SPEC	(
470	IDEN	stringIn
470	OPER	[
470	IDEN	x
470	OPER	]
470	OPER	==
470	CHAR	_
470	SPEC	)
470	OPER	||
470	SPEC	(
470	IDEN	stringIn
470	OPER	[
470	IDEN	x
470	OPER	]
470	OPER	>=
470	CHAR	a
470	OPER	&&
470	IDEN	stringIn
470	OPER	[
470	IDEN	x
470	OPER	]
470	OPER	<=
470	CHAR	z
470	SPEC	)
470	SPEC	)
470	SPEC	{
471	IDEN	stringArray
471	OPER	[
471	IDEN	y
471	OPER	]
471	OPER	=
471	IDEN	stringIn
471	OPER	[
471	IDEN	x
471	OPER	]
471	SPEC	;
472	IDEN	y
472	OPER	++
472	SPEC	;
473	IDEN	x
473	OPER	++
473	SPEC	;
474	SPEC	}
475	IDEN	x
475	OPER	--
475	SPEC	;
476	IDEN	fprintf
476	SPEC	(
476	IDEN	Out
476	OPER	,
476	STR	%d 
476	OPER	,
476	IDEN	lineNo
476	SPEC	)
476	SPEC	;
477	IDEN	fprintf
477	SPEC	(
477	IDEN	Out
477	OPER	,
477	STR	IDEN 
477	SPEC	)
477	SPEC	;
478	IDEN	fprintf
478	SPEC	(
478	IDEN	Out
478	OPER	,
478	STR	%s  \n
478	OPER	,
478	IDEN	stringArray
478	SPEC	)
478	SPEC	;
479	REWD	break
479	SPEC	;
480	SPEC	}
481	IDEN	y
481	OPER	=
481	INTE	0
481	SPEC	;
482	REWD	int
482	IDEN	loop4
482	OPER	=
482	INTE	0
482	SPEC	;
483	REWD	while
483	SPEC	(
483	IDEN	loop4
483	OPER	<
483	INTE	50
483	SPEC	)
483	SPEC	{
484	IDEN	stringArray
484	OPER	[
484	IDEN	loop4
484	OPER	]
484	OPER	=
484	CHAR	 
484	SPEC	;
485	IDEN	loop4
485	OPER	++
485	SPEC	;
486	SPEC	}
487	REWD	break
487	SPEC	;
488	REWD	case
488	CHAR	s
488	SPEC	:
489	IDEN	stringArray
489	OPER	[
489	IDEN	y
489	OPER	]
489	OPER	=
489	IDEN	stringIn
489	OPER	[
489	IDEN	x
489	OPER	]
489	SPEC	;
490	IDEN	x
490	OPER	++
490	SPEC	;
491	IDEN	y
491	OPER	++
491	SPEC	;
492	REWD	switch
492	SPEC	(
492	IDEN	stringIn
492	OPER	[
492	IDEN	x
492	OPER	]
492	SPEC	)
492	SPEC	{
493	REWD	case
493	CHAR	w
493	SPEC	:
494	IDEN	stringArray
494	OPER	[
494	IDEN	y
494	OPER	]
494	OPER	=
494	IDEN	stringIn
494	OPER	[
494	IDEN	x
494	OPER	]
494	SPEC	;
495	IDEN	x
495	OPER	++
495	SPEC	;
496	IDEN	y
496	OPER	++
496	SPEC	;
497	REWD	if
497	SPEC	(
497	SPEC	(
497	IDEN	stringIn
497	OPER	[
497	IDEN	x
497	OPER	]
497	OPER	==
497	CHAR	i
497	SPEC	)
497	OPER	&&
497	SPEC	(
497	IDEN	stringIn
497	OPER	[
497	IDEN	x
497	OPER	]
497	OPER	==
497	CHAR	t
497	SPEC	)
497	OPER	&&
497	SPEC	(
497	IDEN	stringIn
497	OPER	[
497	IDEN	x
497	OPER	]
497	OPER	==
497	CHAR	c
497	SPEC	)
497	OPER	&&
497	SPEC	(
497	IDEN	stringIn
497	OPER	[
497	IDEN	x
497	OPER	]
497	OPER	==
497	CHAR	h
497	SPEC	)
497	SPEC	)
497	SPEC	{
498	IDEN	x
498	OPER	++
498	SPEC	;
499	IDEN	x
499	OPER	++
499	SPEC	;
500	IDEN	x
500	OPER	++
500	SPEC	;
501	IDEN	fprintf
501	SPEC	(
501	IDEN	Out
501	OPER	,
501	STR	%d 
501	OPER	,
501	IDEN	lineNo
501	SPEC	)
501	SPEC	;
502	IDEN	fprintf
502	SPEC	(
502	IDEN	Out
502	OPER	,
502	STR	REWD 
502	SPEC	)
502	SPEC	;
503	IDEN	fprintf
503	SPEC	(
503	IDEN	Out
503	OPER	,
503	STR	switch \n
503	SPEC	)
503	SPEC	;
504	SPEC	}
505	REWD	else
505	SPEC	{
506	REWD	while
506	SPEC	(
506	SPEC	(
506	IDEN	stringIn
506	OPER	[
506	IDEN	x
506	OPER	]
506	OPER	>=
506	CHAR	A
506	OPER	&&
506	IDEN	stringIn
506	OPER	[
506	IDEN	x
506	OPER	]
506	OPER	<=
506	CHAR	Z
506	SPEC	)
506	OPER	||
506	SPEC	(
506	IDEN	stringIn
506	OPER	[
506	IDEN	x
506	OPER	]
506	OPER	==
506	CHAR	_
506	SPEC	)
506	OPER	||
506	SPEC	(
506	IDEN	stringIn
506	OPER	[
506	IDEN	x
506	OPER	]
506	OPER	>=
506	CHAR	a
506	OPER	&&
506	IDEN	stringIn
506	OPER	[
506	IDEN	x
506	OPER	]
506	OPER	<=
506	CHAR	z
506	SPEC	)
506	SPEC	)
506	SPEC	{
507	IDEN	stringArray
507	OPER	[
507	IDEN	y
507	OPER	]
507	OPER	=
507	IDEN	stringIn
507	OPER	[
507	IDEN	x
507	OPER	]
507	SPEC	;
508	IDEN	y
508	OPER	++
508	SPEC	;
509	IDEN	x
509	OPER	++
509	SPEC	;
510	SPEC	}
511	IDEN	x
511	OPER	--
511	SPEC	;
512	IDEN	fprintf
512	SPEC	(
512	IDEN	Out
512	OPER	,
512	STR	%d 
512	OPER	,
512	IDEN	lineNo
512	SPEC	)
512	SPEC	;
513	IDEN	fprintf
513	SPEC	(
513	IDEN	Out
513	OPER	,
513	STR	IDEN 
513	SPEC	)
513	SPEC	;
514	IDEN	fprintf
514	SPEC	(
514	IDEN	Out
514	OPER	,
514	STR	%s  \n
514	OPER	,
514	IDEN	stringArray
514	SPEC	)
514	SPEC	;
515	SPEC	}
516	REWD	break
516	SPEC	;
518	SPEC	}
519	REWD	switch
519	SPEC	(
519	IDEN	stringIn
519	OPER	[
519	IDEN	x
519	OPER	]
519	SPEC	)
519	SPEC	{
520	REWD	case
520	CHAR	h
520	SPEC	:
521	IDEN	stringArray
521	OPER	[
521	IDEN	y
521	OPER	]
521	OPER	=
521	IDEN	stringIn
521	OPER	[
521	IDEN	x
521	OPER	]
521	SPEC	;
522	IDEN	x
522	OPER	++
522	SPEC	;
523	IDEN	y
523	OPER	++
523	SPEC	;
524	REWD	if
524	SPEC	(
524	SPEC	(
524	IDEN	stringIn
524	OPER	[
524	IDEN	x
524	OPER	]
524	OPER	==
524	CHAR	o
524	SPEC	)
524	OPER	&&
524	SPEC	(
524	IDEN	stringIn
524	OPER	[
524	IDEN	x
524	OPER	]
524	OPER	==
524	CHAR	r
524	SPEC	)
524	OPER	&&
524	SPEC	(
524	IDEN	stringIn
524	OPER	[
524	IDEN	x
524	OPER	]
524	OPER	==
524	CHAR	t
524	SPEC	)
524	SPEC	)
524	SPEC	{
525	IDEN	x
525	OPER	++
525	SPEC	;
526	IDEN	x
526	OPER	++
526	SPEC	;
527	IDEN	x
527	OPER	++
527	SPEC	;
528	IDEN	fprintf
528	SPEC	(
528	IDEN	Out
528	OPER	,
528	STR	%d 
528	OPER	,
528	IDEN	lineNo
528	SPEC	)
528	SPEC	;
529	IDEN	fprintf
529	SPEC	(
529	IDEN	Out
529	OPER	,
529	STR	REWD 
529	SPEC	)
529	SPEC	;
530	IDEN	fprintf
530	SPEC	(
530	IDEN	Out
530	OPER	,
530	STR	short \n
530	SPEC	)
530	SPEC	;
531	SPEC	}
532	REWD	else
532	SPEC	{
533	REWD	while
533	SPEC	(
533	SPEC	(
533	IDEN	stringIn
533	OPER	[
533	IDEN	x
533	OPER	]
533	OPER	>=
533	CHAR	A
533	OPER	&&
533	IDEN	stringIn
533	OPER	[
533	IDEN	x
533	OPER	]
533	OPER	<=
533	CHAR	Z
533	SPEC	)
533	OPER	||
533	SPEC	(
533	IDEN	stringIn
533	OPER	[
533	IDEN	x
533	OPER	]
533	OPER	==
533	CHAR	_
533	SPEC	)
533	OPER	||
533	SPEC	(
533	IDEN	stringIn
533	OPER	[
533	IDEN	x
533	OPER	]
533	OPER	>=
533	CHAR	a
533	OPER	&&
533	IDEN	stringIn
533	OPER	[
533	IDEN	x
533	OPER	]
533	OPER	<=
533	CHAR	z
533	SPEC	)
533	SPEC	)
533	SPEC	{
534	IDEN	stringArray
534	OPER	[
534	IDEN	y
534	OPER	]
534	OPER	=
534	IDEN	stringIn
534	OPER	[
534	IDEN	x
534	OPER	]
534	SPEC	;
535	IDEN	y
535	OPER	++
535	SPEC	;
536	IDEN	x
536	OPER	++
536	SPEC	;
537	SPEC	}
538	IDEN	x
538	OPER	--
538	SPEC	;
539	IDEN	fprintf
539	SPEC	(
539	IDEN	Out
539	OPER	,
539	STR	%d 
539	OPER	,
539	IDEN	lineNo
539	SPEC	)
539	SPEC	;
540	IDEN	fprintf
540	SPEC	(
540	IDEN	Out
540	OPER	,
540	STR	IDEN 
540	SPEC	)
540	SPEC	;
541	IDEN	fprintf
541	SPEC	(
541	IDEN	Out
541	OPER	,
541	STR	%s  \n
541	OPER	,
541	IDEN	stringArray
541	SPEC	)
541	SPEC	;
542	SPEC	}
543	REWD	break
543	SPEC	;
544	SPEC	}
545	REWD	switch
545	SPEC	(
545	IDEN	stringIn
545	OPER	[
545	IDEN	x
545	OPER	]
545	SPEC	)
545	SPEC	{
546	REWD	case
546	CHAR	i
546	SPEC	:
547	IDEN	stringArray
547	OPER	[
547	IDEN	y
547	OPER	]
547	OPER	=
547	IDEN	stringIn
547	OPER	[
547	IDEN	x
547	OPER	]
547	SPEC	;
548	IDEN	x
548	OPER	++
548	SPEC	;
549	IDEN	y
549	OPER	++
549	SPEC	;
550	REWD	if
550	SPEC	(
550	SPEC	(
550	IDEN	stringIn
550	OPER	[
550	IDEN	x
550	OPER	]
550	OPER	==
550	CHAR	g
550	SPEC	)
550	OPER	&&
550	SPEC	(
550	IDEN	stringIn
550	OPER	[
550	IDEN	x
550	OPER	]
550	OPER	==
550	CHAR	n
550	SPEC	)
550	OPER	&&
550	SPEC	(
550	IDEN	stringIn
550	OPER	[
550	IDEN	x
550	OPER	]
550	OPER	==
550	CHAR	e
550	SPEC	)
550	OPER	&&
550	SPEC	(
550	IDEN	stringIn
550	OPER	[
550	IDEN	x
550	OPER	]
550	OPER	==
550	CHAR	d
550	SPEC	)
550	SPEC	)
550	SPEC	{
551	IDEN	x
551	OPER	++
551	SPEC	;
552	IDEN	x
552	OPER	++
552	SPEC	;
553	IDEN	x
553	OPER	++
553	SPEC	;
554	IDEN	fprintf
554	SPEC	(
554	IDEN	Out
554	OPER	,
554	STR	%d 
554	OPER	,
554	IDEN	lineNo
554	SPEC	)
554	SPEC	;
555	IDEN	fprintf
555	SPEC	(
555	IDEN	Out
555	OPER	,
555	STR	REWD 
555	SPEC	)
555	SPEC	;
556	IDEN	fprintf
556	SPEC	(
556	IDEN	Out
556	OPER	,
556	STR	signed \n
556	SPEC	)
556	SPEC	;
557	SPEC	}
558	REWD	else
558	SPEC	{
559	REWD	while
559	SPEC	(
559	SPEC	(
559	IDEN	stringIn
559	OPER	[
559	IDEN	x
559	OPER	]
559	OPER	>=
559	CHAR	A
559	OPER	&&
559	IDEN	stringIn
559	OPER	[
559	IDEN	x
559	OPER	]
559	OPER	<=
559	CHAR	Z
559	SPEC	)
559	OPER	||
559	SPEC	(
559	IDEN	stringIn
559	OPER	[
559	IDEN	x
559	OPER	]
559	OPER	==
559	CHAR	_
559	SPEC	)
559	OPER	||
559	SPEC	(
559	IDEN	stringIn
559	OPER	[
559	IDEN	x
559	OPER	]
559	OPER	>=
559	CHAR	a
559	OPER	&&
559	IDEN	stringIn
559	OPER	[
559	IDEN	x
559	OPER	]
559	OPER	<=
559	CHAR	z
559	SPEC	)
559	SPEC	)
559	SPEC	{
560	IDEN	stringArray
560	OPER	[
560	IDEN	y
560	OPER	]
560	OPER	=
560	IDEN	stringIn
560	OPER	[
560	IDEN	x
560	OPER	]
560	SPEC	;
561	IDEN	y
561	OPER	++
561	SPEC	;
562	IDEN	x
562	OPER	++
562	SPEC	;
563	SPEC	}
564	IDEN	x
564	OPER	--
564	SPEC	;
565	IDEN	fprintf
565	SPEC	(
565	IDEN	Out
565	OPER	,
565	STR	%d 
565	OPER	,
565	IDEN	lineNo
565	SPEC	)
565	SPEC	;
566	IDEN	fprintf
566	SPEC	(
566	IDEN	Out
566	OPER	,
566	STR	IDEN 
566	SPEC	)
566	SPEC	;
567	IDEN	fprintf
567	SPEC	(
567	IDEN	Out
567	OPER	,
567	STR	%s  \n
567	OPER	,
567	IDEN	stringArray
567	SPEC	)
567	SPEC	;
568	SPEC	}
569	REWD	break
569	SPEC	;
570	REWD	default
570	SPEC	:
571	REWD	while
571	SPEC	(
571	SPEC	(
571	IDEN	stringIn
571	OPER	[
571	IDEN	x
571	OPER	]
571	OPER	>=
571	CHAR	A
571	OPER	&&
571	IDEN	stringIn
571	OPER	[
571	IDEN	x
571	OPER	]
571	OPER	<=
571	CHAR	Z
571	SPEC	)
571	OPER	||
571	SPEC	(
571	IDEN	stringIn
571	OPER	[
571	IDEN	x
571	OPER	]
571	OPER	==
571	CHAR	_
571	SPEC	)
571	OPER	||
571	SPEC	(
571	IDEN	stringIn
571	OPER	[
571	IDEN	x
571	OPER	]
571	OPER	>=
571	CHAR	a
571	OPER	&&
571	IDEN	stringIn
571	OPER	[
571	IDEN	x
571	OPER	]
571	OPER	<=
571	CHAR	z
571	SPEC	)
571	SPEC	)
571	SPEC	{
572	IDEN	stringArray
572	OPER	[
572	IDEN	y
572	OPER	]
572	OPER	=
572	IDEN	stringIn
572	OPER	[
572	IDEN	x
572	OPER	]
572	SPEC	;
573	IDEN	y
573	OPER	++
573	SPEC	;
574	IDEN	x
574	OPER	++
574	SPEC	;
575	SPEC	}
576	IDEN	x
576	OPER	--
576	SPEC	;
577	IDEN	fprintf
577	SPEC	(
577	IDEN	Out
577	OPER	,
577	STR	%d 
577	OPER	,
577	IDEN	lineNo
577	SPEC	)
577	SPEC	;
578	IDEN	fprintf
578	SPEC	(
578	IDEN	Out
578	OPER	,
578	STR	IDEN 
578	SPEC	)
578	SPEC	;
579	IDEN	fprintf
579	SPEC	(
579	IDEN	Out
579	OPER	,
579	STR	%s  \n
579	OPER	,
579	IDEN	stringArray
579	SPEC	)
579	SPEC	;
580	REWD	break
580	SPEC	;
581	SPEC	}
582	IDEN	y
582	OPER	=
582	INTE	0
582	SPEC	;
583	REWD	int
583	IDEN	loop6
583	OPER	=
583	INTE	0
583	SPEC	;
584	REWD	while
584	SPEC	(
584	IDEN	loop6
584	OPER	<
584	INTE	50
584	SPEC	)
584	SPEC	{
585	IDEN	stringArray
585	OPER	[
585	IDEN	loop6
585	OPER	]
585	OPER	=
585	CHAR	 
585	SPEC	;
586	IDEN	loop6
586	OPER	++
586	SPEC	;
587	SPEC	}
588	REWD	break
588	SPEC	;
589	REWD	case
589	CHAR	d
589	SPEC	:
590	IDEN	stringArray
590	OPER	[
590	IDEN	y
590	OPER	]
590	OPER	=
590	IDEN	stringIn
590	OPER	[
590	IDEN	x
590	OPER	]
590	SPEC	;
591	IDEN	x
591	OPER	++
591	SPEC	;
592	IDEN	y
592	OPER	++
592	SPEC	;
593	REWD	switch
593	SPEC	(
593	IDEN	stringIn
593	OPER	[
593	IDEN	x
593	OPER	]
593	SPEC	)
593	SPEC	{
594	REWD	case
594	CHAR	o
594	SPEC	:
595	REWD	if
595	SPEC	(
595	SPEC	(
595	IDEN	stringIn
595	OPER	[
595	IDEN	x
595	OPER	]
595	OPER	==
595	CHAR	u
595	SPEC	)
595	OPER	&&
595	SPEC	(
595	IDEN	stringIn
595	OPER	[
595	IDEN	x
595	OPER	]
595	OPER	==
595	CHAR	b
595	SPEC	)
595	OPER	&&
595	SPEC	(
595	IDEN	stringIn
595	OPER	[
595	IDEN	x
595	OPER	]
595	OPER	==
595	CHAR	l
595	SPEC	)
595	OPER	&&
595	SPEC	(
595	IDEN	stringIn
595	OPER	[
595	IDEN	x
595	OPER	]
595	OPER	==
595	CHAR	e
595	SPEC	)
595	SPEC	)
595	SPEC	{
596	IDEN	x
596	OPER	++
596	SPEC	;
597	IDEN	x
597	OPER	++
597	SPEC	;
598	IDEN	x
598	OPER	++
598	SPEC	;
599	IDEN	x
599	OPER	++
599	SPEC	;
600	IDEN	fprintf
600	SPEC	(
600	IDEN	Out
600	OPER	,
600	STR	%d 
600	OPER	,
600	IDEN	lineNo
600	SPEC	)
600	SPEC	;
601	IDEN	fprintf
601	SPEC	(
601	IDEN	Out
601	OPER	,
601	STR	REWD 
601	SPEC	)
601	SPEC	;
602	IDEN	fprintf
602	SPEC	(
602	IDEN	Out
602	OPER	,
602	STR	double \n
602	SPEC	)
602	SPEC	;
603	SPEC	}
604	REWD	else
604	SPEC	{
605	IDEN	fprintf
605	SPEC	(
605	IDEN	Out
605	OPER	,
605	STR	%d 
605	OPER	,
605	IDEN	lineNo
605	SPEC	)
605	SPEC	;
606	IDEN	fprintf
606	SPEC	(
606	IDEN	Out
606	OPER	,
606	STR	REWD 
606	SPEC	)
606	SPEC	;
607	IDEN	fprintf
607	SPEC	(
607	IDEN	Out
607	OPER	,
607	STR	do \n
607	SPEC	)
607	SPEC	;
608	SPEC	}
609	REWD	break
609	SPEC	;
610	REWD	default
610	SPEC	:
611	REWD	while
611	SPEC	(
611	SPEC	(
611	IDEN	stringIn
611	OPER	[
611	IDEN	x
611	OPER	]
611	OPER	>=
611	CHAR	A
611	OPER	&&
611	IDEN	stringIn
611	OPER	[
611	IDEN	x
611	OPER	]
611	OPER	<=
611	CHAR	Z
611	SPEC	)
611	OPER	||
611	SPEC	(
611	IDEN	stringIn
611	OPER	[
611	IDEN	x
611	OPER	]
611	OPER	==
611	CHAR	_
611	SPEC	)
611	OPER	||
611	SPEC	(
611	IDEN	stringIn
611	OPER	[
611	IDEN	x
611	OPER	]
611	OPER	>=
611	CHAR	a
611	OPER	&&
611	IDEN	stringIn
611	OPER	[
611	IDEN	x
611	OPER	]
611	OPER	<=
611	CHAR	z
611	SPEC	)
611	SPEC	)
611	SPEC	{
612	IDEN	stringArray
612	OPER	[
612	IDEN	y
612	OPER	]
612	OPER	=
612	IDEN	stringIn
612	OPER	[
612	IDEN	x
612	OPER	]
612	SPEC	;
613	IDEN	y
613	OPER	++
613	SPEC	;
614	IDEN	x
614	OPER	++
614	SPEC	;
615	SPEC	}
616	IDEN	x
616	OPER	--
616	SPEC	;
617	IDEN	fprintf
617	SPEC	(
617	IDEN	Out
617	OPER	,
617	STR	%d 
617	OPER	,
617	IDEN	lineNo
617	SPEC	)
617	SPEC	;
618	IDEN	fprintf
618	SPEC	(
618	IDEN	Out
618	OPER	,
618	STR	IDEN 
618	SPEC	)
618	SPEC	;
619	IDEN	fprintf
619	SPEC	(
619	IDEN	Out
619	OPER	,
619	STR	%s  \n
619	OPER	,
619	IDEN	stringArray
619	SPEC	)
619	SPEC	;
620	REWD	break
620	SPEC	;
621	SPEC	}
622	IDEN	y
622	OPER	=
622	INTE	0
622	SPEC	;
623	REWD	int
623	IDEN	loop5
623	OPER	=
623	INTE	0
623	SPEC	;
624	REWD	while
624	SPEC	(
624	IDEN	loop5
624	OPER	<
624	INTE	50
624	SPEC	)
624	SPEC	{
625	IDEN	stringArray
625	OPER	[
625	IDEN	loop5
625	OPER	]
625	OPER	=
625	CHAR	 
625	SPEC	;
626	IDEN	loop5
626	OPER	++
626	SPEC	;
627	SPEC	}
628	REWD	break
628	SPEC	;
629	REWD	case
629	CHAR	c
629	SPEC	:
630	IDEN	stringArray
630	OPER	[
630	IDEN	y
630	OPER	]
630	OPER	=
630	IDEN	stringIn
630	OPER	[
630	IDEN	x
630	OPER	]
630	SPEC	;
631	IDEN	x
631	OPER	++
631	SPEC	;
632	IDEN	y
632	OPER	++
632	SPEC	;
633	REWD	switch
633	SPEC	(
633	IDEN	stringIn
633	OPER	[
633	IDEN	x
633	OPER	]
633	SPEC	)
633	SPEC	{
634	REWD	case
634	CHAR	o
634	SPEC	:
635	IDEN	stringArray
635	OPER	[
635	IDEN	y
635	OPER	]
635	OPER	=
635	IDEN	stringIn
635	OPER	[
635	IDEN	x
635	OPER	]
635	SPEC	;
636	IDEN	x
636	OPER	++
636	SPEC	;
637	IDEN	y
637	OPER	++
637	SPEC	;
638	REWD	if
638	SPEC	(
638	SPEC	(
638	IDEN	stringIn
638	OPER	[
638	IDEN	x
638	OPER	]
638	OPER	==
638	CHAR	n
638	SPEC	)
638	OPER	&&
638	SPEC	(
638	IDEN	stringIn
638	OPER	[
638	IDEN	x
638	OPER	]
638	OPER	==
638	CHAR	s
638	SPEC	)
638	OPER	&&
638	SPEC	(
638	IDEN	stringIn
638	OPER	[
638	IDEN	x
638	OPER	]
638	OPER	==
638	CHAR	t
638	SPEC	)
638	SPEC	)
638	SPEC	{
639	IDEN	x
639	OPER	++
639	SPEC	;
640	IDEN	fprintf
640	SPEC	(
640	IDEN	Out
640	OPER	,
640	STR	%d 
640	OPER	,
640	IDEN	lineNo
640	SPEC	)
640	SPEC	;
641	IDEN	fprintf
641	SPEC	(
641	IDEN	Out
641	OPER	,
641	STR	REWD 
641	SPEC	)
641	SPEC	;
642	IDEN	fprintf
642	SPEC	(
642	IDEN	Out
642	OPER	,
642	STR	const \n
642	SPEC	)
642	SPEC	;
643	SPEC	}
644	REWD	else
644	SPEC	{
645	REWD	while
645	SPEC	(
645	SPEC	(
645	IDEN	stringIn
645	OPER	[
645	IDEN	x
645	OPER	]
645	OPER	>=
645	CHAR	A
645	OPER	&&
645	IDEN	stringIn
645	OPER	[
645	IDEN	x
645	OPER	]
645	OPER	<=
645	CHAR	Z
645	SPEC	)
645	OPER	||
645	SPEC	(
645	IDEN	stringIn
645	OPER	[
645	IDEN	x
645	OPER	]
645	OPER	==
645	CHAR	_
645	SPEC	)
645	OPER	||
645	SPEC	(
645	IDEN	stringIn
645	OPER	[
645	IDEN	x
645	OPER	]
645	OPER	>=
645	CHAR	a
645	OPER	&&
645	IDEN	stringIn
645	OPER	[
645	IDEN	x
645	OPER	]
645	OPER	<=
645	CHAR	z
645	SPEC	)
645	SPEC	)
645	SPEC	{
646	IDEN	stringArray
646	OPER	[
646	IDEN	y
646	OPER	]
646	OPER	=
646	IDEN	stringIn
646	OPER	[
646	IDEN	x
646	OPER	]
646	SPEC	;
647	IDEN	y
647	OPER	++
647	SPEC	;
648	IDEN	x
648	OPER	++
648	SPEC	;
649	SPEC	}
650	IDEN	x
650	OPER	--
650	SPEC	;
651	IDEN	fprintf
651	SPEC	(
651	IDEN	Out
651	OPER	,
651	STR	%d 
651	OPER	,
651	IDEN	lineNo
651	SPEC	)
651	SPEC	;
652	IDEN	fprintf
652	SPEC	(
652	IDEN	Out
652	OPER	,
652	STR	IDEN 
652	SPEC	)
652	SPEC	;
653	IDEN	fprintf
653	SPEC	(
653	IDEN	Out
653	OPER	,
653	STR	%s  \n
653	OPER	,
653	IDEN	stringArray
653	SPEC	)
653	SPEC	;
654	SPEC	}
655	REWD	break
655	SPEC	;
656	REWD	case
656	CHAR	a
656	SPEC	:
657	IDEN	stringArray
657	OPER	[
657	IDEN	y
657	OPER	]
657	OPER	=
657	IDEN	stringIn
657	OPER	[
657	IDEN	x
657	OPER	]
657	SPEC	;
658	IDEN	x
658	OPER	++
658	SPEC	;
659	IDEN	y
659	OPER	++
659	SPEC	;
660	REWD	if
660	SPEC	(
660	SPEC	(
660	IDEN	stringIn
660	OPER	[
660	IDEN	x
660	OPER	]
660	OPER	==
660	CHAR	s
660	SPEC	)
660	OPER	&&
660	SPEC	(
660	IDEN	stringIn
660	OPER	[
660	IDEN	x
660	OPER	]
660	OPER	==
660	CHAR	e
660	SPEC	)
660	SPEC	)
660	SPEC	{
661	IDEN	x
661	OPER	++
661	SPEC	;
662	IDEN	fprintf
662	SPEC	(
662	IDEN	Out
662	OPER	,
662	STR	%d 
662	OPER	,
662	IDEN	lineNo
662	SPEC	)
662	SPEC	;
663	IDEN	fprintf
663	SPEC	(
663	IDEN	Out
663	OPER	,
663	STR	REWD 
663	SPEC	)
663	SPEC	;
664	IDEN	fprintf
664	SPEC	(
664	IDEN	Out
664	OPER	,
664	STR	case \n
664	SPEC	)
664	SPEC	;
665	SPEC	}
666	REWD	else
666	SPEC	{
667	REWD	while
667	SPEC	(
667	SPEC	(
667	IDEN	stringIn
667	OPER	[
667	IDEN	x
667	OPER	]
667	OPER	>=
667	CHAR	A
667	OPER	&&
667	IDEN	stringIn
667	OPER	[
667	IDEN	x
667	OPER	]
667	OPER	<=
667	CHAR	Z
667	SPEC	)
667	OPER	||
667	SPEC	(
667	IDEN	stringIn
667	OPER	[
667	IDEN	x
667	OPER	]
667	OPER	==
667	CHAR	_
667	SPEC	)
667	OPER	||
667	SPEC	(
667	IDEN	stringIn
667	OPER	[
667	IDEN	x
667	OPER	]
667	OPER	>=
667	CHAR	a
667	OPER	&&
667	IDEN	stringIn
667	OPER	[
667	IDEN	x
667	OPER	]
667	OPER	<=
667	CHAR	z
667	SPEC	)
667	SPEC	)
667	SPEC	{
668	IDEN	stringArray
668	OPER	[
668	IDEN	y
668	OPER	]
668	OPER	=
668	IDEN	stringIn
668	OPER	[
668	IDEN	x
668	OPER	]
668	SPEC	;
669	IDEN	y
669	OPER	++
669	SPEC	;
670	IDEN	x
670	OPER	++
670	SPEC	;
671	SPEC	}
672	IDEN	x
672	OPER	--
672	SPEC	;
673	IDEN	fprintf
673	SPEC	(
673	IDEN	Out
673	OPER	,
673	STR	%d 
673	OPER	,
673	IDEN	lineNo
673	SPEC	)
673	SPEC	;
674	IDEN	fprintf
674	SPEC	(
674	IDEN	Out
674	OPER	,
674	STR	IDEN 
674	SPEC	)
674	SPEC	;
675	IDEN	fprintf
675	SPEC	(
675	IDEN	Out
675	OPER	,
675	STR	%s  \n
675	OPER	,
675	IDEN	stringArray
675	SPEC	)
675	SPEC	;
676	SPEC	}
677	REWD	break
677	SPEC	;
678	REWD	case
678	CHAR	h
678	SPEC	:
679	IDEN	stringArray
679	OPER	[
679	IDEN	y
679	OPER	]
679	OPER	=
679	IDEN	stringIn
679	OPER	[
679	IDEN	x
679	OPER	]
679	SPEC	;
680	IDEN	x
680	OPER	++
680	SPEC	;
681	IDEN	y
681	OPER	++
681	SPEC	;
682	REWD	if
682	SPEC	(
682	SPEC	(
682	IDEN	stringIn
682	OPER	[
682	IDEN	x
682	OPER	]
682	OPER	==
682	CHAR	a
682	SPEC	)
682	OPER	&&
682	SPEC	(
682	IDEN	stringIn
682	OPER	[
682	IDEN	x
682	OPER	]
682	OPER	==
682	CHAR	r
682	SPEC	)
682	SPEC	)
682	SPEC	{
683	IDEN	x
683	OPER	++
683	SPEC	;
684	IDEN	fprintf
684	SPEC	(
684	IDEN	Out
684	OPER	,
684	STR	%d 
684	OPER	,
684	IDEN	lineNo
684	SPEC	)
684	SPEC	;
685	IDEN	fprintf
685	SPEC	(
685	IDEN	Out
685	OPER	,
685	STR	REWD 
685	SPEC	)
685	SPEC	;
686	IDEN	fprintf
686	SPEC	(
686	IDEN	Out
686	OPER	,
686	STR	char \n
686	SPEC	)
686	SPEC	;
687	SPEC	}
688	REWD	else
688	SPEC	{
689	REWD	while
689	SPEC	(
689	SPEC	(
689	IDEN	stringIn
689	OPER	[
689	IDEN	x
689	OPER	]
689	OPER	>=
689	CHAR	A
689	OPER	&&
689	IDEN	stringIn
689	OPER	[
689	IDEN	x
689	OPER	]
689	OPER	<=
689	CHAR	Z
689	SPEC	)
689	OPER	||
689	SPEC	(
689	IDEN	stringIn
689	OPER	[
689	IDEN	x
689	OPER	]
689	OPER	==
689	CHAR	_
689	SPEC	)
689	OPER	||
689	SPEC	(
689	IDEN	stringIn
689	OPER	[
689	IDEN	x
689	OPER	]
689	OPER	>=
689	CHAR	a
689	OPER	&&
689	IDEN	stringIn
689	OPER	[
689	IDEN	x
689	OPER	]
689	OPER	<=
689	CHAR	z
689	SPEC	)
689	SPEC	)
689	SPEC	{
690	IDEN	stringArray
690	OPER	[
690	IDEN	y
690	OPER	]
690	OPER	=
690	IDEN	stringIn
690	OPER	[
690	IDEN	x
690	OPER	]
690	SPEC	;
691	IDEN	y
691	OPER	++
691	SPEC	;
692	IDEN	x
692	OPER	++
692	SPEC	;
693	SPEC	}
694	IDEN	x
694	OPER	--
694	SPEC	;
695	IDEN	fprintf
695	SPEC	(
695	IDEN	Out
695	OPER	,
695	STR	%d 
695	OPER	,
695	IDEN	lineNo
695	SPEC	)
695	SPEC	;
696	IDEN	fprintf
696	SPEC	(
696	IDEN	Out
696	OPER	,
696	STR	IDEN 
696	SPEC	)
696	SPEC	;
697	IDEN	fprintf
697	SPEC	(
697	IDEN	Out
697	OPER	,
697	STR	%s  \n
697	OPER	,
697	IDEN	stringArray
697	SPEC	)
697	SPEC	;
698	SPEC	}
699	REWD	break
699	SPEC	;
700	REWD	default
700	SPEC	:
701	REWD	while
701	SPEC	(
701	SPEC	(
701	IDEN	stringIn
701	OPER	[
701	IDEN	x
701	OPER	]
701	OPER	>=
701	CHAR	A
701	OPER	&&
701	IDEN	stringIn
701	OPER	[
701	IDEN	x
701	OPER	]
701	OPER	<=
701	CHAR	Z
701	SPEC	)
701	OPER	||
701	SPEC	(
701	IDEN	stringIn
701	OPER	[
701	IDEN	x
701	OPER	]
701	OPER	==
701	CHAR	_
701	SPEC	)
701	OPER	||
701	SPEC	(
701	IDEN	stringIn
701	OPER	[
701	IDEN	x
701	OPER	]
701	OPER	>=
701	CHAR	a
701	OPER	&&
701	IDEN	stringIn
701	OPER	[
701	IDEN	x
701	OPER	]
701	OPER	<=
701	CHAR	z
701	SPEC	)
701	SPEC	)
701	SPEC	{
702	IDEN	stringArray
702	OPER	[
702	IDEN	y
702	OPER	]
702	OPER	=
702	IDEN	stringIn
702	OPER	[
702	IDEN	x
702	OPER	]
702	SPEC	;
703	IDEN	y
703	OPER	++
703	SPEC	;
704	IDEN	x
704	OPER	++
704	SPEC	;
705	SPEC	}
706	IDEN	x
706	OPER	--
706	SPEC	;
707	IDEN	fprintf
707	SPEC	(
707	IDEN	Out
707	OPER	,
707	STR	%d 
707	OPER	,
707	IDEN	lineNo
707	SPEC	)
707	SPEC	;
708	IDEN	fprintf
708	SPEC	(
708	IDEN	Out
708	OPER	,
708	STR	IDEN 
708	SPEC	)
708	SPEC	;
709	IDEN	fprintf
709	SPEC	(
709	IDEN	Out
709	OPER	,
709	STR	%s  \n
709	OPER	,
709	IDEN	stringArray
709	SPEC	)
709	SPEC	;
710	REWD	break
710	SPEC	;
711	SPEC	}
712	IDEN	y
712	OPER	=
712	INTE	0
712	SPEC	;
713	REWD	int
713	IDEN	loop7
713	OPER	=
713	INTE	0
713	SPEC	;
714	REWD	while
714	SPEC	(
714	IDEN	loop7
714	OPER	<
714	INTE	50
714	SPEC	)
714	SPEC	{
715	IDEN	stringArray
715	OPER	[
715	IDEN	loop7
715	OPER	]
715	OPER	=
715	CHAR	 
715	SPEC	;
716	IDEN	loop7
716	OPER	++
716	SPEC	;
717	SPEC	}
718	REWD	break
718	SPEC	;
719	REWD	case
719	CHAR	a
719	SPEC	:
719	REWD	case
719	CHAR	b
719	SPEC	:
719	REWD	case
719	CHAR	h
719	SPEC	:
719	REWD	case
719	CHAR	j
719	SPEC	:
719	REWD	case
719	CHAR	k
719	SPEC	:
719	REWD	case
719	CHAR	Y
719	SPEC	:
719	REWD	case
719	CHAR	Z
719	SPEC	:
719	REWD	case
719	CHAR	_
719	SPEC	:
719	REWD	case
719	CHAR	m
719	SPEC	:
719	REWD	case
719	CHAR	n
719	SPEC	:
720	REWD	case
720	CHAR	r
720	SPEC	:
720	REWD	case
720	CHAR	x
720	SPEC	:
720	REWD	case
720	CHAR	y
720	SPEC	:
720	REWD	case
720	CHAR	Q
720	SPEC	:
720	REWD	case
720	CHAR	R
720	SPEC	:
720	REWD	case
720	CHAR	T
720	SPEC	:
720	REWD	case
720	CHAR	U
720	SPEC	:
720	REWD	case
720	CHAR	V
720	SPEC	:
720	REWD	case
720	CHAR	X
720	SPEC	:
721	REWD	case
721	CHAR	z
721	SPEC	:
721	REWD	case
721	CHAR	A
721	SPEC	:
721	REWD	case
721	CHAR	B
721	SPEC	:
721	REWD	case
721	CHAR	G
721	SPEC	:
721	REWD	case
721	CHAR	H
721	SPEC	:
721	REWD	case
721	CHAR	J
721	SPEC	:
721	REWD	case
721	CHAR	K
721	SPEC	:
721	REWD	case
721	CHAR	L
721	SPEC	:
721	REWD	case
721	CHAR	M
721	SPEC	:
721	REWD	case
721	CHAR	N
721	SPEC	:
721	REWD	case
721	CHAR	O
721	SPEC	:
721	REWD	case
721	CHAR	P
721	SPEC	:
722	REWD	case
722	CHAR	o
722	SPEC	:
722	REWD	case
722	CHAR	p
722	SPEC	:
722	REWD	case
722	CHAR	q
722	SPEC	:
723	IDEN	stringArray
723	OPER	[
723	IDEN	y
723	OPER	]
723	OPER	=
723	IDEN	stringIn
723	OPER	[
723	IDEN	x
723	OPER	]
723	SPEC	;
724	IDEN	x
724	OPER	++
724	SPEC	;
725	IDEN	y
725	OPER	++
725	SPEC	;
726	REWD	if
726	SPEC	(
726	SPEC	(
726	IDEN	stringIn
726	OPER	[
726	IDEN	x
726	OPER	]
726	OPER	>=
726	CHAR	a
726	OPER	&&
726	IDEN	stringIn
726	OPER	[
726	IDEN	x
726	OPER	]
726	OPER	<=
726	CHAR	z
726	SPEC	)
726	OPER	||
726	SPEC	(
726	IDEN	stringIn
726	OPER	[
726	IDEN	x
726	OPER	]
726	OPER	>=
726	CHAR	A
726	OPER	&&
726	IDEN	stringIn
726	OPER	[
726	IDEN	x
726	OPER	]
726	OPER	<=
726	CHAR	Z
726	SPEC	)
726	OPER	||
726	SPEC	(
726	IDEN	stringIn
726	OPER	[
726	IDEN	x
726	OPER	]
726	OPER	==
726	CHAR	_
726	SPEC	)
726	SPEC	)
726	SPEC	{
727	REWD	while
727	SPEC	(
727	SPEC	(
727	IDEN	stringIn
727	OPER	[
727	IDEN	x
727	OPER	]
727	OPER	>=
727	CHAR	A
727	OPER	&&
727	IDEN	stringIn
727	OPER	[
727	IDEN	x
727	OPER	]
727	OPER	<=
727	CHAR	Z
727	SPEC	)
727	OPER	||
727	SPEC	(
727	IDEN	stringIn
727	OPER	[
727	IDEN	x
727	OPER	]
727	OPER	>=
727	CHAR	a
727	OPER	&&
727	IDEN	stringIn
727	OPER	[
727	IDEN	x
727	OPER	]
727	OPER	<=
727	CHAR	z
727	SPEC	)
727	OPER	||
727	SPEC	(
727	IDEN	stringIn
727	OPER	[
727	IDEN	x
727	OPER	]
727	OPER	==
727	CHAR	_
727	SPEC	)
727	SPEC	)
727	SPEC	{
728	IDEN	stringArray
728	OPER	[
728	IDEN	y
728	OPER	]
728	OPER	=
728	IDEN	stringIn
728	OPER	[
728	IDEN	x
728	OPER	]
728	SPEC	;
729	IDEN	y
729	OPER	++
729	SPEC	;
730	IDEN	x
730	OPER	++
730	SPEC	;
731	SPEC	}
732	SPEC	}
733	IDEN	x
733	OPER	--
733	SPEC	;
734	IDEN	fprintf
734	SPEC	(
734	IDEN	Out
734	OPER	,
734	STR	%d 
734	OPER	,
734	IDEN	lineNo
734	SPEC	)
734	SPEC	;
735	IDEN	fprintf
735	SPEC	(
735	IDEN	Out
735	OPER	,
735	STR	IDEN 
735	SPEC	)
735	SPEC	;
736	IDEN	fprintf
736	SPEC	(
736	IDEN	Out
736	OPER	,
736	STR	%s  \n
736	OPER	,
736	IDEN	stringArray
736	SPEC	)
736	SPEC	;
737	IDEN	y
737	OPER	=
737	INTE	0
737	SPEC	;
738	REWD	int
738	IDEN	loop9
738	OPER	=
738	INTE	0
738	SPEC	;
739	REWD	while
739	SPEC	(
739	IDEN	loop9
739	OPER	<
739	INTE	50
739	SPEC	)
739	SPEC	{
740	IDEN	stringArray
740	OPER	[
740	IDEN	loop9
740	OPER	]
740	OPER	=
740	CHAR	 
740	SPEC	;
741	IDEN	loop9
741	OPER	++
741	SPEC	;
742	SPEC	}
743	REWD	break
743	SPEC	;
744	REWD	case
744	CHAR	{
744	SPEC	:
745	IDEN	fprintf
745	SPEC	(
745	IDEN	Out
745	OPER	,
745	STR	%d 
745	OPER	,
745	IDEN	lineNo
745	SPEC	)
745	SPEC	;
746	IDEN	fprintf
746	SPEC	(
746	IDEN	Out
746	OPER	,
746	STR	SPEC 
746	SPEC	)
746	SPEC	;
747	IDEN	fprintf
747	SPEC	(
747	IDEN	Out
747	OPER	,
747	STR	{ \n
747	SPEC	)
747	SPEC	;
748	REWD	break
748	SPEC	;
749	REWD	case
749	CHAR	}
749	SPEC	:
750	IDEN	fprintf
750	SPEC	(
750	IDEN	Out
750	OPER	,
750	STR	%d 
750	OPER	,
750	IDEN	lineNo
750	SPEC	)
750	SPEC	;
751	IDEN	fprintf
751	SPEC	(
751	IDEN	Out
751	OPER	,
751	STR	SPEC 
751	SPEC	)
751	SPEC	;
752	IDEN	fprintf
752	SPEC	(
752	IDEN	Out
752	OPER	,
752	STR	} \n
752	SPEC	)
752	SPEC	;
753	REWD	break
753	SPEC	;
754	REWD	case
754	CHAR	(
754	SPEC	:
755	IDEN	fprintf
755	SPEC	(
755	IDEN	Out
755	OPER	,
755	STR	%d 
755	OPER	,
755	IDEN	lineNo
755	SPEC	)
755	SPEC	;
756	IDEN	fprintf
756	SPEC	(
756	IDEN	Out
756	OPER	,
756	STR	SPEC 
756	SPEC	)
756	SPEC	;
757	IDEN	fprintf
757	SPEC	(
757	IDEN	Out
757	OPER	,
757	STR	( \n
757	SPEC	)
757	SPEC	;
758	REWD	break
758	SPEC	;
759	REWD	case
759	CHAR	)
759	SPEC	:
760	IDEN	fprintf
760	SPEC	(
760	IDEN	Out
760	OPER	,
760	STR	%d 
760	OPER	,
760	IDEN	lineNo
760	SPEC	)
760	SPEC	;
761	IDEN	fprintf
761	SPEC	(
761	IDEN	Out
761	OPER	,
761	STR	SPEC 
761	SPEC	)
761	SPEC	;
762	IDEN	fprintf
762	SPEC	(
762	IDEN	Out
762	OPER	,
762	STR	) \n
762	SPEC	)
762	SPEC	;
763	REWD	break
763	SPEC	;
764	REWD	case
764	CHAR	;
764	SPEC	:
765	IDEN	fprintf
765	SPEC	(
765	IDEN	Out
765	OPER	,
765	STR	%d 
765	OPER	,
765	IDEN	lineNo
765	SPEC	)
765	SPEC	;
766	IDEN	fprintf
766	SPEC	(
766	IDEN	Out
766	OPER	,
766	STR	SPEC 
766	SPEC	)
766	SPEC	;
767	IDEN	fprintf
767	SPEC	(
767	IDEN	Out
767	OPER	,
767	STR	; \n
767	SPEC	)
767	SPEC	;
768	REWD	break
768	SPEC	;
769	REWD	case
769	CHAR	0
769	SPEC	:
769	REWD	case
769	CHAR	1
769	SPEC	:
769	REWD	case
769	CHAR	6
769	SPEC	:
769	REWD	case
769	CHAR	7
769	SPEC	:
769	REWD	case
769	CHAR	8
769	SPEC	:
769	REWD	case
769	CHAR	9
769	SPEC	:
769	REWD	case
769	CHAR	2
769	SPEC	:
769	REWD	case
769	CHAR	3
769	SPEC	:
769	REWD	case
769	CHAR	4
769	SPEC	:
769	REWD	case
769	CHAR	5
769	SPEC	:
770	IDEN	stringArray
770	OPER	[
770	IDEN	y
770	OPER	]
770	OPER	=
770	IDEN	stringIn
770	OPER	[
770	IDEN	x
770	OPER	]
770	SPEC	;
771	IDEN	x
771	OPER	++
771	SPEC	;
772	IDEN	y
772	OPER	++
772	SPEC	;
773	REWD	while
773	SPEC	(
773	IDEN	stringIn
773	OPER	[
773	IDEN	x
773	OPER	]
773	OPER	>=
773	CHAR	0
773	OPER	&&
773	IDEN	stringIn
773	OPER	[
773	IDEN	x
773	OPER	]
773	OPER	<=
773	CHAR	9
773	SPEC	)
773	SPEC	{
774	IDEN	stringArray
774	OPER	[
774	IDEN	y
774	OPER	]
774	OPER	=
774	IDEN	stringIn
774	OPER	[
774	IDEN	x
774	OPER	]
774	SPEC	;
775	IDEN	x
775	OPER	++
775	SPEC	;
776	IDEN	y
776	OPER	++
776	SPEC	;
777	SPEC	}
778	REWD	if
778	SPEC	(
778	IDEN	stringIn
778	OPER	[
778	IDEN	x
778	OPER	]
778	OPER	==
778	CHAR	.
778	SPEC	)
778	SPEC	{
779	IDEN	stringArray
779	OPER	[
779	IDEN	y
779	OPER	]
779	OPER	=
779	IDEN	stringIn
779	OPER	[
779	IDEN	x
779	OPER	]
779	SPEC	;
780	IDEN	x
780	OPER	++
780	SPEC	;
781	IDEN	y
781	OPER	++
781	SPEC	;
782	REWD	while
782	SPEC	(
782	IDEN	stringIn
782	OPER	[
782	IDEN	x
782	OPER	]
782	OPER	>=
782	CHAR	0
782	OPER	&&
782	IDEN	stringIn
782	OPER	[
782	IDEN	x
782	OPER	]
782	OPER	<=
782	CHAR	9
782	SPEC	)
782	SPEC	{
783	IDEN	stringArray
783	OPER	[
783	IDEN	y
783	OPER	]
783	OPER	=
783	IDEN	stringIn
783	OPER	[
783	IDEN	x
783	OPER	]
783	SPEC	;
784	IDEN	x
784	OPER	++
784	SPEC	;
785	IDEN	y
785	OPER	++
785	SPEC	;
786	SPEC	}
787	REWD	if
787	SPEC	(
787	SPEC	(
787	IDEN	stringIn
787	OPER	[
787	IDEN	x
787	OPER	]
787	OPER	==
787	CHAR	e
787	SPEC	)
787	OPER	||
787	SPEC	(
787	IDEN	stringIn
787	OPER	[
787	IDEN	x
787	OPER	]
787	OPER	==
787	CHAR	E
787	SPEC	)
787	SPEC	)
787	SPEC	{
788	IDEN	stringArray
788	OPER	[
788	IDEN	y
788	OPER	]
788	OPER	=
788	IDEN	stringIn
788	OPER	[
788	IDEN	x
788	OPER	]
788	SPEC	;
789	IDEN	x
789	OPER	++
789	SPEC	;
790	IDEN	y
790	OPER	++
790	SPEC	;
791	REWD	if
791	SPEC	(
791	SPEC	(
791	IDEN	stringIn
791	OPER	[
791	IDEN	x
791	OPER	]
791	OPER	==
791	CHAR	+
791	SPEC	)
791	OPER	||
791	SPEC	(
791	IDEN	stringIn
791	OPER	[
791	IDEN	x
791	OPER	]
791	OPER	==
791	CHAR	-
791	SPEC	)
791	OPER	||
791	SPEC	(
791	IDEN	stringIn
791	OPER	[
791	IDEN	x
791	OPER	]
791	OPER	>=
791	CHAR	0
791	OPER	&&
791	IDEN	stringIn
791	OPER	[
791	IDEN	x
791	OPER	]
791	OPER	<=
791	CHAR	9
791	SPEC	)
791	SPEC	)
791	SPEC	{
792	IDEN	stringArray
792	OPER	[
792	IDEN	y
792	OPER	]
792	OPER	=
792	IDEN	stringIn
792	OPER	[
792	IDEN	x
792	OPER	]
792	SPEC	;
793	IDEN	x
793	OPER	++
793	SPEC	;
794	IDEN	y
794	OPER	++
794	SPEC	;
795	REWD	while
795	SPEC	(
795	IDEN	stringIn
795	OPER	[
795	IDEN	x
795	OPER	]
795	OPER	>=
795	CHAR	0
795	OPER	&&
795	IDEN	stringIn
795	OPER	[
795	IDEN	x
795	OPER	]
795	OPER	<=
795	CHAR	9
795	SPEC	)
795	SPEC	{
796	IDEN	stringArray
796	OPER	[
796	IDEN	y
796	OPER	]
796	OPER	=
796	IDEN	stringIn
796	OPER	[
796	IDEN	x
796	OPER	]
796	SPEC	;
797	IDEN	x
797	OPER	++
797	SPEC	;
798	IDEN	y
798	OPER	++
798	SPEC	;
799	SPEC	}
800	SPEC	}
801	SPEC	}
802	IDEN	x
802	OPER	--
802	SPEC	;
803	IDEN	fprintf
803	SPEC	(
803	IDEN	Out
803	OPER	,
803	STR	%d 
803	OPER	,
803	IDEN	lineNo
803	SPEC	)
803	SPEC	;
804	IDEN	fprintf
804	SPEC	(
804	IDEN	Out
804	OPER	,
804	STR	FLOT 
804	SPEC	)
804	SPEC	;
805	IDEN	fprintf
805	SPEC	(
805	IDEN	Out
805	OPER	,
805	STR	%s  \n
805	OPER	,
805	IDEN	stringArray
805	SPEC	)
805	SPEC	;
806	SPEC	}
807	REWD	else
807	SPEC	{
808	IDEN	fprintf
808	SPEC	(
808	IDEN	Out
808	OPER	,
808	STR	%d 
808	OPER	,
808	IDEN	lineNo
808	SPEC	)
808	SPEC	;
809	IDEN	fprintf
809	SPEC	(
809	IDEN	Out
809	OPER	,
809	STR	INTE 
809	SPEC	)
809	SPEC	;
810	IDEN	fprintf
810	SPEC	(
810	IDEN	Out
810	OPER	,
810	STR	%s  \n
810	OPER	,
810	IDEN	stringArray
810	SPEC	)
810	SPEC	;
811	IDEN	x
811	OPER	--
811	SPEC	;
812	SPEC	}
813	IDEN	y
813	OPER	=
813	INTE	0
813	SPEC	;
814	REWD	int
814	IDEN	loop8
814	OPER	=
814	INTE	0
814	SPEC	;
815	REWD	while
815	SPEC	(
815	IDEN	loop8
815	OPER	<
815	INTE	50
815	SPEC	)
815	SPEC	{
816	IDEN	stringArray
816	OPER	[
816	IDEN	loop8
816	OPER	]
816	OPER	=
816	CHAR	 
816	SPEC	;
817	IDEN	loop8
817	OPER	++
817	SPEC	;
818	SPEC	}
819	REWD	break
819	SPEC	;
821	REWD	case
821	CHAR	+
821	SPEC	:
822	IDEN	fprintf
822	SPEC	(
822	IDEN	Out
822	OPER	,
822	STR	%d 
822	OPER	,
822	IDEN	lineNo
822	SPEC	)
822	SPEC	;
823	IDEN	fprintf
823	SPEC	(
823	IDEN	Out
823	OPER	,
823	STR	OPER 
823	SPEC	)
823	SPEC	;
824	IDEN	fprintf
824	SPEC	(
824	IDEN	Out
824	OPER	,
824	STR	+ \n
824	SPEC	)
824	SPEC	;
825	REWD	break
825	SPEC	;
826	REWD	case
826	CHAR	=
826	SPEC	:
827	IDEN	fprintf
827	SPEC	(
827	IDEN	Out
827	OPER	,
827	STR	%d 
827	OPER	,
827	IDEN	lineNo
827	SPEC	)
827	SPEC	;
828	IDEN	fprintf
828	SPEC	(
828	IDEN	Out
828	OPER	,
828	STR	OPER 
828	SPEC	)
828	SPEC	;
829	IDEN	fprintf
829	SPEC	(
829	IDEN	Out
829	OPER	,
829	STR	= \n
829	SPEC	)
829	SPEC	;
830	REWD	break
830	SPEC	;
831	REWD	case
831	CHAR	-
831	SPEC	:
832	IDEN	fprintf
832	SPEC	(
832	IDEN	Out
832	OPER	,
832	STR	%d 
832	OPER	,
832	IDEN	lineNo
832	SPEC	)
832	SPEC	;
833	IDEN	fprintf
833	SPEC	(
833	IDEN	Out
833	OPER	,
833	STR	OPER 
833	SPEC	)
833	SPEC	;
834	IDEN	fprintf
834	SPEC	(
834	IDEN	Out
834	OPER	,
834	STR	- \n
834	SPEC	)
834	SPEC	;
835	REWD	break
835	SPEC	;
836	REWD	case
836	CHAR	*
836	SPEC	:
837	IDEN	fprintf
837	SPEC	(
837	IDEN	Out
837	OPER	,
837	STR	%d 
837	OPER	,
837	IDEN	lineNo
837	SPEC	)
837	SPEC	;
838	IDEN	fprintf
838	SPEC	(
838	IDEN	Out
838	OPER	,
838	STR	OPER 
838	SPEC	)
838	SPEC	;
839	IDEN	fprintf
839	SPEC	(
839	IDEN	Out
839	OPER	,
839	STR	* \n
839	SPEC	)
839	SPEC	;
840	REWD	break
840	SPEC	;
841	REWD	case
841	CHAR	,
841	SPEC	:
842	IDEN	fprintf
842	SPEC	(
842	IDEN	Out
842	OPER	,
842	STR	%d 
842	OPER	,
842	IDEN	lineNo
842	SPEC	)
842	SPEC	;
843	IDEN	fprintf
843	SPEC	(
843	IDEN	Out
843	OPER	,
843	STR	OPER 
843	SPEC	)
843	SPEC	;
844	IDEN	fprintf
844	SPEC	(
844	IDEN	Out
844	OPER	,
844	STR	, \n
844	SPEC	)
844	SPEC	;
845	REWD	break
845	SPEC	;
846	REWD	case
846	CHAR	%
846	SPEC	:
847	IDEN	fprintf
847	SPEC	(
847	IDEN	Out
847	OPER	,
847	STR	%d 
847	OPER	,
847	IDEN	lineNo
847	SPEC	)
847	SPEC	;
848	IDEN	fprintf
848	SPEC	(
848	IDEN	Out
848	OPER	,
848	STR	OPER 
848	SPEC	)
848	SPEC	;
849	IDEN	fprintf
849	SPEC	(
849	IDEN	Out
849	OPER	,
849	STR	% \n
849	SPEC	)
849	SPEC	;
850	REWD	break
850	SPEC	;
851	REWD	case
851	CHAR	>
851	SPEC	:
852	IDEN	fprintf
852	SPEC	(
852	IDEN	Out
852	OPER	,
852	STR	%d 
852	OPER	,
852	IDEN	lineNo
852	SPEC	)
852	SPEC	;
853	IDEN	fprintf
853	SPEC	(
853	IDEN	Out
853	OPER	,
853	STR	OPER 
853	SPEC	)
853	SPEC	;
854	IDEN	fprintf
854	SPEC	(
854	IDEN	Out
854	OPER	,
854	STR	> \n
854	SPEC	)
854	SPEC	;
855	REWD	break
855	SPEC	;
856	REWD	case
856	CHAR	<
856	SPEC	:
857	IDEN	fprintf
857	SPEC	(
857	IDEN	Out
857	OPER	,
857	STR	%d 
857	OPER	,
857	IDEN	lineNo
857	SPEC	)
857	SPEC	;
858	IDEN	fprintf
858	SPEC	(
858	IDEN	Out
858	OPER	,
858	STR	OPER 
858	SPEC	)
858	SPEC	;
859	IDEN	fprintf
859	SPEC	(
859	IDEN	Out
859	OPER	,
859	STR	< \n
859	SPEC	)
859	SPEC	;
860	REWD	break
860	SPEC	;
861	REWD	case
861	CHAR	!
861	SPEC	:
862	IDEN	fprintf
862	SPEC	(
862	IDEN	Out
862	OPER	,
862	STR	%d 
862	OPER	,
862	IDEN	lineNo
862	SPEC	)
862	SPEC	;
863	IDEN	fprintf
863	SPEC	(
863	IDEN	Out
863	OPER	,
863	STR	OPER 
863	SPEC	)
863	SPEC	;
864	IDEN	fprintf
864	SPEC	(
864	IDEN	Out
864	OPER	,
864	STR	! \n
864	SPEC	)
864	SPEC	;
865	REWD	break
865	SPEC	;
866	REWD	case
866	CHAR	&
866	SPEC	:
867	IDEN	fprintf
867	SPEC	(
867	IDEN	Out
867	OPER	,
867	STR	%d 
867	OPER	,
867	IDEN	lineNo
867	SPEC	)
867	SPEC	;
868	IDEN	fprintf
868	SPEC	(
868	IDEN	Out
868	OPER	,
868	STR	OPER 
868	SPEC	)
868	SPEC	;
869	IDEN	fprintf
869	SPEC	(
869	IDEN	Out
869	OPER	,
869	STR	& \n
869	SPEC	)
869	SPEC	;
870	REWD	break
870	SPEC	;
871	REWD	case
871	CHAR	[
871	SPEC	:
872	IDEN	fprintf
872	SPEC	(
872	IDEN	Out
872	OPER	,
872	STR	%d 
872	OPER	,
872	IDEN	lineNo
872	SPEC	)
872	SPEC	;
873	IDEN	fprintf
873	SPEC	(
873	IDEN	Out
873	OPER	,
873	STR	OPER 
873	SPEC	)
873	SPEC	;
874	IDEN	fprintf
874	SPEC	(
874	IDEN	Out
874	OPER	,
874	STR	[ \n
874	SPEC	)
874	SPEC	;
875	REWD	break
875	SPEC	;
876	REWD	case
876	CHAR	]
876	SPEC	:
877	IDEN	fprintf
877	SPEC	(
877	IDEN	Out
877	OPER	,
877	STR	%d 
877	OPER	,
877	IDEN	lineNo
877	SPEC	)
877	SPEC	;
878	IDEN	fprintf
878	SPEC	(
878	IDEN	Out
878	OPER	,
878	STR	OPER 
878	SPEC	)
878	SPEC	;
879	IDEN	fprintf
879	SPEC	(
879	IDEN	Out
879	OPER	,
879	STR	] \n
879	SPEC	)
879	SPEC	;
880	REWD	break
880	SPEC	;
881	REWD	case
881	CHAR	|
881	SPEC	:
882	IDEN	fprintf
882	SPEC	(
882	IDEN	Out
882	OPER	,
882	STR	%d 
882	OPER	,
882	IDEN	lineNo
882	SPEC	)
882	SPEC	;
883	IDEN	fprintf
883	SPEC	(
883	IDEN	Out
883	OPER	,
883	STR	OPER 
883	SPEC	)
883	SPEC	;
884	IDEN	fprintf
884	SPEC	(
884	IDEN	Out
884	OPER	,
884	STR	| \n
884	SPEC	)
884	SPEC	;
885	REWD	break
885	SPEC	;
886	REWD	case
886	CHAR	^
886	SPEC	:
887	IDEN	fprintf
887	SPEC	(
887	IDEN	Out
887	OPER	,
887	STR	%d 
887	OPER	,
887	IDEN	lineNo
887	SPEC	)
887	SPEC	;
888	IDEN	fprintf
888	SPEC	(
888	IDEN	Out
888	OPER	,
888	STR	OPER 
888	SPEC	)
888	SPEC	;
889	IDEN	fprintf
889	SPEC	(
889	IDEN	Out
889	OPER	,
889	STR	^ \n
889	SPEC	)
889	SPEC	;
890	REWD	break
890	SPEC	;
891	REWD	case
891	CHAR	.
891	SPEC	:
892	IDEN	fprintf
892	SPEC	(
892	IDEN	Out
892	OPER	,
892	STR	%d 
892	OPER	,
892	IDEN	lineNo
892	SPEC	)
892	SPEC	;
893	IDEN	fprintf
893	SPEC	(
893	IDEN	Out
893	OPER	,
893	STR	OPER 
893	SPEC	)
893	SPEC	;
894	IDEN	fprintf
894	SPEC	(
894	IDEN	Out
894	OPER	,
894	STR	. \n
894	SPEC	)
894	SPEC	;
895	REWD	break
895	SPEC	;
896	REWD	default
896	SPEC	:
897	REWD	break
897	SPEC	;
898	SPEC	}
899	IDEN	x
899	OPER	++
899	SPEC	;
900	SPEC	}
901	IDEN	lineNo
901	OPER	++
901	SPEC	;
902	REWD	int
902	IDEN	loop
902	OPER	=
902	INTE	0
902	SPEC	;
903	REWD	while
903	SPEC	(
903	IDEN	loop
903	OPER	<
903	INTE	50
903	SPEC	)
903	SPEC	{
904	IDEN	stringArray
904	OPER	[
904	IDEN	loop
904	OPER	]
904	OPER	=
904	CHAR	 
904	SPEC	;
905	IDEN	loop
905	OPER	++
905	SPEC	;
906	SPEC	}
907	IDEN	fprintf
907	SPEC	(
907	IDEN	Out
907	OPER	,
907	STR	\n
907	SPEC	)
907	SPEC	;
908	SPEC	}
909	IDEN	fclose
909	SPEC	(
909	IDEN	In
909	SPEC	)
909	SPEC	;
910	IDEN	fclose
910	SPEC	(
910	IDEN	Out
910	SPEC	)
910	SPEC	;
911	IDEN	system
911	SPEC	(
911	STR	PAUSE
911	SPEC	)
911	SPEC	;
912	REWD	return
912	INTE	0
912	SPEC	;
913	SPEC	}
